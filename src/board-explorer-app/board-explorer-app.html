<!doctype html>
<!--
@license
Copyright (C) 2017 Intel Corporation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<html>
<head>
  <link rel="import" href="../../bower_components/polymer/polymer.html">
  <link rel="import" href="../../bower_components/app-layout/app-drawer/app-drawer.html">

  <link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
  <link rel="import" href="../../bower_components/iron-icons/iron-icons.html">
  <link rel="import" href="../../bower_components/iron-icon/iron-icon.html">
  <link rel="import" href="../../bower_components/iron-media-query/iron-media-query.html">
  <link rel="import" href="../../bower_components/iron-pages/iron-pages.html">
  <link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">

  <link rel="import" href="../../bower_components/paper-button/paper-button.html">
  <link rel="import" href="../../bower_components/paper-dropdown-menu/paper-dropdown-menu.html">
  <link rel="import" href="../../bower_components/paper-input/paper-input.html">
  <link rel="import" href="../../bower_components/paper-item/paper-item.html">
  <link rel="import" href="../../bower_components/paper-listbox/paper-listbox.html">
  <link rel="import" href="../../bower_components/paper-material/paper-material.html">
  <link rel="import" href="../../bower_components/paper-tabs/paper-tabs.html">
  <link rel="import" href="../../bower_components/paper-tabs/paper-tab.html">
  <link rel="import" href="../../bower_components/paper-toolbar/paper-toolbar.html">

  <link rel="import" href="../../bower_components/vaadin-split-layout/vaadin-split-layout.html">

  <link rel="import" href="../../bower_components/board-viewer/board-viewer.html">

  <script src="../../bower_components/highlightjs/highlight.pack.min.js"></script>

  <link rel="stylesheet" href="../../bower_components/highlightjs/styles/atom-one-light.css">

  <link rel="stylesheet" href="../../fonts/clearsans.css">

  <!--
  `<board-explorer-app>` Provides a board-explorer container for the board-viewer.

  The board-explorer loads the board-viewer and displays additional selection
  elements for interacting with the board-viewer. It also provides an area
  to render the documentation for a given item (via board-viewer::getDocumentation)

  @demo demo/index.html Simple demo showing a statically loaded view.
  -->

  <style>
  body,* {
    font-family: ClearSansRegular,Helvetica Neue,Helvetica,Arial,sans-serif;
  }

  b,strong {
    font-family: ClearSansBold,Helvetica Neue,Helvetica,Arial,sans-serif;
  }
  </style>

</head>

<dom-module id="board-explorer-app">
<template>
  <style include="iron-flex iron-flex-alignment iron-positioning">
    :host {
      /* Colors from UX mockups */
      --color-green: #02e089;
      --color-dark-gray: #22252e;
      --color-font: #fbfbfb;
      --color-light-gray: #38424b;
      --color-heading-background: #3c404c;

      /* Used in board-viewer tab header */
      --focus-foreground-color: #52595a;
      --focus-background-color: #d6eab0;
      --focus-border-color: #97ca41;
      --blur-foreground-color: #52595a;
      --blur-background-color: #f8f8f1;
      --blur-border-color: #f0efe0;
      --bg-l: #f8f8f1;

      --paper-font-common-base: {
        font-family: ClearSansThin,Helvetica Neue,Helvetica,Arial,sans-serif;
        -webkit-font-smoothing: antialiased;
      };
    }

    a,
    a:visited {
      color: var(--color-green);
      text-decoration: none;
    }

    a:hover,
    a:active,
    a:visited {
      text-decoration: underline;
    }

    ul {
      list-style: none;
    }

    ul li::before {
      content: "â€¢";
      padding-right: 0.5em;
      color: var(--color-green);
    }

    #boardTitle {
      padding: 1em;
      cursor: pointer;
      font-family: ClearSansBold,Helvetica Neue,Helvetica,Arial,sans-serif;
      font-weight: bold;
    }

    #searchTabs {
      --paper-tabs-selection-bar-color: var(--color-green);
    }

    paper-input {
      --paper-input-container-focus-color: var(--color-green);
      --paper-input-container-input-color: var(--color-font);
    }

    #searchTabs paper-tab {
      text-transform: uppercase;
    }

    #searchTabs iron-icon {
      --iron-icon-width: 1.5em;
      --iron-icon-height: 1.5em;
    }

    #searchPage {
      display: block;
    }

    app-drawer {
      background: white;
      overflow: auto;
      z-index: 10;
      top: 0;
      bottom: 0;
      --app-drawer-width: 100%;
      --app-drawer-scrim-background: rgb(255, 255, 255);
    }

    app-drawer {
      --app-drawer-content-container: {
        padding: 0 !important;
      }
    }

    board-viewer {
      position: relative;
      height: 480px;
    }

    #drawer {
      --app-drawer-content-container: {
        margin: 0;
        padding: 0;
        background-color: var(--color-dark-gray);
      };
    }

    .multi-board #hamburger {
      @apply(--layout-self-start);
    }

    .single-board #hamburger {
      @apply(--layout-self-center);
    }


    #left-menu {
      overflow: hidden;
      background-color: var(--color-heading-background);
      color: var(--color-font);
    }

    #left-contents {
      z-index: 1000;
      box-sizing: border-box;
      width: 100%;
      height: 100%;
    }

    #left-pages {
      color: var(--color-font);
      padding: 2em 1em;
      overflow-x: auto;
      overflow-y: scroll;
    }

    .page-title {
      margin: 1.25em 0.25em;
    }

    .button-list {
      padding: 0;
      margin: 0;
      box-sizing: border-box;
    }

    #layout paper-button {
      cursor: pointer;
      box-sizing: border-box;
      padding: 0.25em 1.1em;
      margin: 0.25em 0.25em;
      border-radius: 2.2em;
      border: 1px solid rgba(0, 0, 0, 0.5);
      min-width: 8em;
      display: inline-block;
      overflow: hidden;
      text-overflow: ellipsis;
      word-wrap: break-word;
      text-decoration: none;
      background-color: var(--color-light-gray);
      color: var(--color-font);
      font-size: 1em;
      min-height: 2.2em;
      text-align: center;
    }

    #layout paper-button[selected],
    #layout paper-button[focused] {
      font-weight: bold;
      font-family: ClearSansBold;
    }

    #layout paper-button.hover,
    #layout paper-button:hover {
      background-color: var(--color-heading-background);
      border-color: var(--color-green);
      color: var(--color-green);
    }

    #layout paper-button.connected {
      border-color: #ff8000;
      color: #ff8000;
      background-color: #888;
    }

    #layout paper-button.related {
      border-color: #00ff00;
      color: #00ff00;
      background-color: #888;
    }

    #layout paper-button.active {
      background-color: #e0e0e0;
    }

    #layout paper-button.item-with-name div {
      display: inline-block
    }

    #layout paper-button.search-result > div:first-child {
      font-size: 0.9em;
    }

    #layout paper-button.search-result > div:last-child {
      padding-top: 0.2em;
      font-size: 0.8em;
      padding-bottom: 0.2em;
    }

    #layout paper-button.item-with-name div:first-child::after {
      content: ": ";
    }

    #layout paper-button.item-with-name div:last-child {
    }

    #layout paper-button:not(.item-with-name) div:first-child {
    }

    paper-material {
      margin: 0.5em;
      padding: 1em;
    }

    .info-content {
      margin: 1em;
    }

    .documentation table {
      border: 1px solid black;
      width: 100%;
      margin-bottom: 0.5em;
    }

    .info-content a {
      margin-right: 0.25em;
    }

    paper-toolbar {
      --paper-toolbar-background: #f0f0f0;
      --paper-toolbar-color: #444;
      --paper-toolbar-sm-height: 64px;
      padding: 0;
      margin: 0;
      -webkit-transition: 0.15s all ease;
      transition: 0.15s all ease;
    }

    paper-dropdown-menu {
      width: 100%;
    }

    #tooltip {
      position: absolute;
      left: 0px;
      right: 0px;
      margin: -64px 32px 0 32px;
      padding: 4px 16px;
      box-shadow: 0px 3px 3px rgba(64, 64, 64, 0.25);
      box-sizing: border-box;
      font-size: 10pt;
      background-color: rgba(64, 64, 64, 0.5);
      color: #fff;
      pointer-events: none;
    }

    /* NOTE: For this to not horribly squash image aspect ratios, we have
     * the item width hard coded to fixed pixels. We could use various
     * image-fill css attributes, but then we might letterbox the wrong
     * part of the image... */
    .board-card {
      width: 320px;
      cursor: pointer;
      border: 3px solid rgba(255, 255, 255, 0);
      padding: 1rem;
      margin: 0.25rem;
    }

    .board-card > * {
    }

    .board-card:not(.filler) {
      @apply(--board-selector-item-theme);
    }

    .board-card:hover:not(.filler) {
      background-color: #d0e8f8;
    }

    /* fill up the space of the last row */
    .filler {
      dispaly: inline-block;
      width: 320px;
      height: 1px;
      max-height: 1px;
      pointer-events: none;
      margin: 0.25rem;
    }

    .filler.tiny,
    .board-card.tiny {
      width: 100%;
    }

    .board-card .title {
      margin: 0.5em 0;
      width: 100%; /* Fix IE not wrapping text in the paper-button */
    }

    .board-card .image {
      position: relative;
      width: 100%;
      height: calc(240px - 2rem);
      background-size: contain;
      background-position: 50% 50%;
      background-repeat: no-repeat;
    }

    #board-selector .heading {
      margin: 0 0 0.5em 0;
      font-weight: bold;
      font-family: ClearSansBold;
    }

    #board-selector paper-button {
      margin: 0.5em;
    }

    #documentation table {
      padding: 0px;
      margin: 0 0 0.5em 0;
      border-spacing: 0px;
      border: 1px solid black;
      width: 100%;
      margin-bottom: 0.5em;
    }

    #documentation th,
    #documentation td {
      border-right: 1px solid black;
      padding: 0 0.5em;
    }

    #documentation td:first-child {
      width: 120px;
    }

    #documentation th {
      border-bottom: 1px solid black;
    }

    #documentation th:last-child,
    #documentation td:last-child {
      border-right: 1px none black;
    }

    #documentation thead:not(:last-child) {
      background: #ddd;
      border-bottom: 1px solid black;
    }

    #documentation thead:not(:first-of-type) {
      border-top: 1px solid black;
    }

    #documentation tbody {
      font-weight: normal;
    }

    #documentation td {
      vertical-align: top;
    }

    #documentation tr {
    }

    #documentation a {
      margin-right: 0.25em;
      text-decoration: none;
    }

    #documentation a:hover {
      text-decoration: underline;
    }



    #layout {
      height: 100%;
      max-height: 100%;
    }

    #vaadin-container {
      height: 100vh;
    }

    .vaadin-left-right {
      --vaadin-split-layout-splitter: {
        fill: var(--color-green);
        background: var(--color-dark-gray);
      };
    }

    #left-pages::-webkit-scrollbar {
      width: 10px;
      background: var(--color-dark-gray);
      cursor: pointer;
    }

    #left-pages::-webkit-scrollbar-thumb {
      border: solid transparent;
      border: 0 3px;
      background-clip: content-box;
      border-radius: 10px;
    	background-color: var(--color-green);
    }

    .vaadin-up-down {
      --vaadin-split-layout-splitter: {
        fill: var(--color-green);
      };
    }

    #layout.mobile {
      height: 100%;
      max-height: 100%;
      margin-left: -10px;
    }

    #panel-left {
      background-color: var(--color-dark-gray);
      box-sizing: border-box;
      width: 512px;
      min-width: 250px;
    }

    #panel-left.constrained {
      font-size: 0.8em;
    }

    #panel-left.constrained paper-tab {
      --paper-tab: {
        font-size: 0.8em;
      };
    }

    #panel-right {
      width: 66.7%;
      max-width: 100%;
      height: 100%;
      box-sizing: border-box;
    }

    /* In single-board mode, there is no top header, so don't set these styles */
    .multi-board.mobile #panel-right {
      position: absolute;
      width: 100%;
    }

    /* The hamburger menu item floats in the upper left; it is hidden
     * when !isMobileMode */
    #overlayMenu {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 5; /* On top of board-viewer, below app-drawer */
      color: #f0f0f0;
    }

    app-drawer paper-icon {
      color: #f0f0f0;
    }

    #info {
      box-sizing: border-box;
    }

    #panel-bottom {
      box-sizing: border-box;
      height: 33.3%;
    }

    /* Fix IE not wrapping correctly in flex wrap layouts */
    .wrap {
      width: 100%;
    }

    .context-and-name {
      margin-right: 0.5ex;
    }

    .context-and-name:not(:last-of-type):not(:first-of-type) {
      padding-right: 0.5ex;
      border-right: 1px solid #d0d0d0;
    }

    .context-and-name div:first-child {
      font-size: 0.75em;
      min-height: 0.75em;
    }

    .context-and-name div:last-child {
      font-size: 1em;
    }
  </style>

  <iron-media-query query="(max-width:480px)" query-matches="{{isMobileLayout}}" on-query-matches-changed="onLayoutChange"></iron-media-query>

  <div id="board-selector" hidden$="[[hideSelector(board,initialized)]]" class="layout vertical start">
    <div class="vertical layout wrap">
      <div class="heading">Select a board to explore</div>
      <div id="board-list" class="layout horizontal start-justified wrap">
        <template is="dom-repeat" items="[[boards]]">
          <paper-button raised noink class="board-card layout vertical" tabindex$="[[index]]" on-tap="boardTap">
            <div class="image" style$="background-image: url('boards/[[item.image]]');">
            </div>
            <div class="title">[[item.name]]</div>
          </paper-button>
        </template>
      </div>
    </div>
  </div>

  <div class$="[[layoutClasses(singleBoardMode, mobileMode)]]" id="layout" hidden$="[[isEmpty(board)]]">

    <!-- In single board mode, the hamburger menu overlays the board-viewer.
         If not in single-board mode, the CSS for this sets it to display:none -->
    <paper-icon-button
        id="overlayMenu"
        hidden$="[[!isMobileLayout]]"
        icon="menu"
        slot="dropdown-trigger"
        alt="menu"
        on-tap="toggleDrawer"></paper-icon-button>

    <app-drawer id="drawer" disable-swipe no-focus-trap class="layout vertical">
      <div id="left-contents" class="flex layout vertical">
        <!-- in mobile mode && !single board mode, the heading is:
        * [icon] | [title]
        *        |=========
        *        | [menu]
        *
        * In mobile mode && single board mode, the heading is:
        * [icon] | [menu]
        -->
        <div id="left-menu" class="horizontal layout">
          <paper-icon-button
              id="hamburger"
              hidden$="[[!isMobileLayout]]"
              icon="menu"
              slot="dropdown-trigger"
              alt="menu"
              on-tap="toggleDrawer"></paper-icon-button>

          <div class="flex layout vertical center-justified">
            <div hidden$="[[singleBoardMode]]"
                id="boardTitle"
                on-tap="unloadBoard"
                class="vertical layout center">
              [[getBoardBoxTitle(board)]]
            </div>

            <paper-tabs
                class="layout horizontal center-justified"
                id="searchTabs"
                selected="{{searchMode}}"
                attr-for-selected="name">
              <paper-tab name="categoriesPage" hidden$="[[isEmpty(categories)]]">Categories</paper-tab>
              <paper-tab name="keywordsPage">Keywords</paper-tab>
              <paper-tab name="componentsPage">Components</paper-tab>
              <paper-tab name="overviewPage" hidden>Get to know the board</paper-tab>
              <paper-tab name="searchPage"><iron-icon icon="search"></iron-icon></paper-tab>
            </paper-tabs>
          </div>
        </div>

        <div id="left-pages" class="flex vertical layout">
          <iron-pages id="pages" selected="[[searchMode]]" attr-for-selected="id">
            <div id="searchPage" class="vertical layout">
              <paper-input id="search" value="{{search}}" label="Search" class="flex">
              </paper-input>
              <div hidden$="[[!isEmpty(search)]]">Enter a string to search (for example "I2C").</div>
              <div hidden$="[[isEmpty(search)]]">
                <div class="page-title">Search results</div>
                <div hidden$="[[!isEmpty(matches)]]">No matches.</div>
                <div class="button-list layout horizontal wrap">
                  <template is="dom-repeat" items="[[matches]]">
                    <paper-button match$="[[item.refdes]]"
                        class="search-result layout vertical start"
                        on-focus="buttonOver"
                        on-blur="buttonOut"
                        on-tap="buttonTap"
                        on-mouseover="buttonOver"
                        on-mouseout="buttonOut">
                      <div>[[itemName(item)]]</div>
                      <div>[[item.field]]: [[item.value]]</div>
                    </paper-button>
                  </template>
                </div>
              </div>
            </div>

            <div id="categoriesPage" class="vertical layout">
              <div class="page-title">Categories</div>
              <div class="button-list layout horizontal wrap">
                <template is="dom-repeat" items="[[categories]]">
                  <paper-button match$="[[item.slug]]"
                      on-focus="buttonOver"
                      on-blur="buttonOut"
                      on-tap="buttonTap"
                      on-mouseover="buttonOver"
                      on-mouseout="buttonOut"
                      selected$="[[item.selected]]">
                    <div>[[item.name]]</div>
                    <div></div>
                  </paper-button>
                </template>
              </div>
            </div>

            <div id="keywordsPage" class="vertical layout">
              <div class="page-title">Keywords</div>
              <div class="button-list horizontal layout wrap">
                <template is="dom-repeat" items="[[keywords]]">
                  <paper-button match$="[[item.refdes]]"
                      on-focus="buttonOver"
                      on-blur="buttonOut"
                      on-tap="buttonTap"
                      on-mouseover="buttonOver"
                      on-mouseout="buttonOut"
                      selected$="[[item.selected]]">
                    <div>[[item.refdes]]</div>
                    <div></div>
                  </paper-button>
                </template>
              </div>
            </div>

            <div id="componentsPage" class="vertical layout start">
              <div class="page-title">Components</div>
              <div class="button-list layout horizontal wrap">
                <template is="dom-repeat" items="[[components]]">
                  <paper-button match$="[[item.refdes]]"
                      class$="[[itemClassList(item)]]"
                      on-focus="buttonOver"
                      on-blur="buttonOut"
                      on-tap="buttonTap"
                      on-mouseover="buttonOver"
                      on-mouseout="buttonOut"
                      selected$="[[item.selected]]">
                      <div>[[itemRefDes(item)]]</div>
                      <template is="dom-if" if="{{itemClassList(item)}}"><div>[[itemName(item)]]</div></template>
                  </paper-button>
                </template>
              </div>
            </div>
          </iron-pages>
        </div>
      </div>
    </app-drawer>

    <vaadin-split-layout class="vaadin-left-right horizontal layout justified" id="vaadin-container">
      <div id="panel-left" hidden$="[[isMobileLayout]]" class$="flex layout vertical [[_panelLeftClass]]">
      </div>

      <vaadin-split-layout vertical id="panel-right" class="vaadin-up-down">
        <board-viewer
          tabindex="0"
          class="flex-grow"
          hidden$="[[isEmpty(board)]]"
          id="boardViewer"
          selected="{{selected}}"
          disable-auto-resize
          scale-tool
          enable-zoom
          enable-drag>
        </board-viewer>
        <div id="panel-bottom">
          <div id="tooltip" hidden$="[[isEmpty(hover)]]"
              class$="[[itemClassList(hover)]] horizontal layout">
            <div hidden$="[[hideReadable(hover)]]"
                class="context-and-name layout vertical justified start">
              <div>&nbsp;</div>
              <div>[[hover.readable]]: </div>
            </div>
            <template is="dom-repeat" items="[[_getItemNamesAndContexts(hover)]]">
              <div class="context-and-name layout vertical justified start">
                <div>[[item.context]]</div>
                <div>[[item.name]]</div>
              </div>
            </template>
          </div>
          <div tabindex="0" id="info"
            hidden$="[[isEmpty(active)]]"
            class$="[[itemClassList(active)]] vertical layout">
            <paper-toolbar>
              <div hidden$="[[hideReadable(active)]]"
                class="context-and-name layout vertical justified start">
                <div>&nbsp;</div>
                <div>[[active.readable]]: </div>
              </div>
              <template is="dom-repeat" items="[[_getItemNamesAndContexts(active)]]">
                <div class="context-and-name layout vertical justified start">
                  <div>[[item.context]]</div>
                  <div>[[item.name]]</div>
                </div>
              </template>
            </paper-toolbar>
            <div class="info-content">
              <div hidden$="[[isEmpty(active.component)]]">Component: [[active.component]]</div>
              <div hidden$="[[isEmpty(active.pins)]]">Pins: [[active.pins.length]]</div>
              <div hidden$="[[isEmpty(active.keywords)]]">
                Keywords: <template is="dom-repeat" items="[[active.keywords]]" as="keyword">
                  <a href="#[[board]]/[[keyword]]">[[keyword]]</a>
                </template>
              </div>
              <div hidden$="[[isEmpty(active.connected)]]">
                Connected to: <template is="dom-repeat" items="[[active.connected]]" as="refdes">
                  <a href="#[[board]]/[[refdes]]">[[lookupName(refdes)]]</a>
                </template>
              </div>
              <div hidden$="[[isEmpty(active.related)]]">
                Related to: <template is="dom-repeat" items="[[active.related]]" as="refdes">
                  <a href="#[[board]]/[[refdes]]">[[lookupName(refdes)]]</a>
                </template>
              </div>
              <div hidden$="[[isEmpty(active.description)]]">Description: [[active.description]]</div>
              <div><div id="documentation"></div></div>
            </div>
          </div>
        </div>
      </vaadin-split-layout>
    </vaadin-split-layout>
  </div>
</template>
<script>
"use strict";

document.addEventListener("WebComponentsReady", function() {
  Polymer({
    is: "board-explorer-app",
    properties: {
      singleBoardMode: {
        type: Boolean,
        value: false
      },
      mobileMode: {
        type: Boolean,
        value: false
      },
      boards: {
        type: Array,
        value: []
      },
      singleBoard: {
        type: String,
        value: "" /* replace with board-name for single board explorer */
      },
      board: {
        type: String,
        value: null
      },
      /** The currently "active" item, which is either the board itself
       * or the first non-keyword in the board-viewer's "selected" list */
      active: {
        type: Object,
        value: null
      },
      categories: {
        type: Array,
        value: []
      },
      category: {
        type: Object,
        value: null
      },
      slug: {
        type: String,
        value: null
      },
      keywords: {
        type: Array,
        value: []
      },

      selected: {
        type: Array,
        value: []
      },

      /** Array of items which match the search pattern. */
      matches: {
        type: Array,
        value: []
      },

      components: {
        type: Array,
        value: []
      },

      pins: {
        type: Array,
        value: []
      },

      /** Item currently hovered over; used for tool-tip */
      hover: {
        type: Object,
        value: null
      },

      fetching: {
        type: Boolean,
        value: false
      },
      initialized: {
        type: Boolean,
        value: false
      },
      isMobileLayout: {
        type: Boolean
      },

      /** Class to apply to left-panel (used for responsive design) */
      _panelLeftClass: {
        type: String,
        value: ""
      }
    },

    observers: [
      "_switchModes(isMobileLayout)",
      "setBoardAndSelectedFromHash(boards, hash)",
      "_searchModeChanged(searchMode)",
      "_searchChanged(search)",
      "_activeChanged(active)"
    ],

    listeners: {
      "vaadin-container.iron-resize": "onPanelLeftResize",
      "boardViewer.board-changed": "onBoardChanged",
      "boardViewer.item-hover": "onBoardItemHover",
      "boardViewer.selected-changed": "onBoardSelectedChanged",
      "search.focused-changed": "_searchFocus"
    },

    _switchModes: function(mobile) {
      var leftContent = this.querySelector("#left-contents"),
        parent;
      if (mobile) {
        console.log("Changing to MOBILE");
        parent = this.$.drawer.$.contentContainer;
      } else {
        console.log("Changing to DESKTOP");
        parent = this.$["panel-left"];
      }

      if (leftContent.parentElement != parent) {
        parent.appendChild(leftContent);
      }
    },

    onPanelLeftResize: function(event) {
      if (this.$["panel-left"].offsetWidth < 480) {
        this._panelLeftClass = "constrained";
      } else {
        this._panelLeftClass = "";
      }
      this.updateStyles();

      //this.debounce("resize", function() {
        /* justify-content: stretch combined with width:auto is not
         * fitting the paper-button items in the button-list container when
         * it is multiple rows of elements */
        if (!this.$.pages.selectedItem) {
           return;
        }
        var container = this.$.pages.selectedItem.querySelector(".button-list");
        var buttons = container.querySelectorAll("paper-button");
        var top, row = [], fitWidth = container.getBoundingClientRect().width, cumulative = 0, gap, marginWidth;

        Array.prototype.forEach.call(buttons, function(button) {
          button.style.minWidth = "8em";
          button.style.width = "auto";
        });

        Array.prototype.forEach.call(buttons, function(button) {
          if (top === undefined) {
            var style = window.getComputedStyle(button);
            top = button.offsetTop;
            marginWidth = parseInt(style.marginLeft) + parseInt(style.marginRight);
          }

          if (button.offsetTop == top) {
            cumulative += Math.ceil(button.getBoundingClientRect().width + marginWidth);
            row.push(button);
          } else {
            gap = Math.floor((fitWidth - cumulative) / row.length);
            row.forEach(function(item, index) {
              /* Account for rounding errors in final item in the row */
              if (index == row.length - 1) {
                gap = (fitWidth - cumulative) - (gap * index) - 1;
              }
              item.style.minWidth = Math.floor(item.getBoundingClientRect().width) + gap + 'px';
            });
            top = button.offsetTop;
            cumulative = button.getBoundingClientRect().width + marginWidth;
            row = [ button ];
          }
        }, 10);

        gap = Math.floor((fitWidth - cumulative) / row.length);
        row.forEach(function(item, index) {
          /* Account for rounding errors in final item in the row */
          if (index == row.length - 1) {
            gap = (fitWidth - cumulative) - (gap * index) - 1;
          }
          item.style.minWidth = Math.floor(item.getBoundingClientRect().width) + gap + 'px';
        });
//      });
    },

    toggleDrawer: function () {
      this.$.drawer.toggle();
    },

    layoutClasses: function(singleBoardMode, mobileMode) {
      var klass = "";

      if (singleBoardMode) {
        klass += " single-board";
      } else {
        klass += " multi-board";
      }

      if (mobileMode) {
        klass += " mobile";
      }

      return klass;
    },

    onLayoutChange: function(event) {
      this.mobileMode = event.detail.value;
      if (!event.displayMode) {
        this.$.drawer.close();
      }
    },

    _activeChanged: function(active) {
      if (!active) {
        return;
      }

      if (active.html) {
        Polymer.dom(this.$.documentation).innerHTML = active.html;
      } else {
        Polymer.dom(this.$.documentation).innerHTML = "Loading...";
        this.loadingQueue(active);
      }
    },

    /* Callback whenever the Search box changes text */
    _searchChanged: function(search) {
      if (this.isEmpty(search)) {
        this.matches = [];
        return;
      }

      var matches = [],
        regexp = new RegExp(search.replace(/[-^$\\*\/+?().|[\]{}]/g, '\\$&'), "i");

      /* Look into an item and try and match various fields for the search string
       * including keywords, names, etc. */
      function _matchItem(regexp, item) {
        var fields = [ "name", "refdes", "description" ];
        for (var i = 0; i < fields.length; i++) {
          var result = regexp.exec(item[fields[i]]);
          if (!result) {
            continue;
          }
          return {
            type: item.type,
            item: item,
            name: item.name || item.readable || "",
            refdes: item.refdes,
            field: fields[i],
            value: item[fields[i]],
            match: result
          };
        }

        if (item.keywords) {
          for (var i = 0; i < item.keywords.length; i++) {
            var result = regexp.exec(item.keywords[i]);
            if (!result) {
              continue;
            }
            return {
              type: item.type,
              item: item,
              refdes: item.refdes,
              name: item.name || item.readable || "",
              field: "keyword",
              value: item.keywords[i],
              match: result
            };
          }
        }
        return null;
      }

      this.components.forEach(function(item) {
        var match = _matchItem(regexp, item);
        if (match) {
          matches.push(match);
        }

        if (item.pins) {
          item.pins.forEach(function(pin) {
            var match = _matchItem(regexp, pin);
            if (match) {
              matches.push(match);
            }
          });
        }
      });

      this.keywords.forEach(function(item) {
        var result = regexp.exec(item.keyword);
        if (!result) {
          return;
        }
        matches.push({
          type: "keyword",
          field: "keyword",
          refdes: item.keyword,
          keyword: item.keyword,
          value: item.keyword,
          match: result
        });
      });

      this.categories.forEach(function(item) {
        var result = regexp.exec(item.name);
        if (!result) {
          return;
        }
        matches.push({
          type: "category",
          field: "category",
          refdes: item.slug,
          value: item.name,
          slug: item.slug,
          match: result
        });
      });

      this.matches = matches;

      /* After the categories, components, or search results change, trigger
       * a re-layout of the left-panel */
      Polymer.dom.flush();
      this.onPanelLeftResize();
    },

    _searchFocus: function(event) {
      if (event.detail.value) {
        this.searchMode = "searchPage";
      }
    },

    _enableItemButtons: function(item) {
      var el;

      if (!item) {
        return;
      }

     Array.prototype.forEach.call(this.$.layout.querySelectorAll("paper-button[match='" + item.refdes + "']"), function(el) {
        delete el.selected;
      });
    },

    onBoardSelectedChanged: function(event) {
      if (!this.board) {
        return;
      }

      var selected = this.$.boardViewer.selected || this.selected;

      /* Disable all items in the currently viewed page*/
      Array.prototype.forEach.call(this.$.layout.querySelectorAll("paper-button"), function(el) {
        delete el.selected;
      });

      /* If no selection is active, then enable everything and return */
      if (selected.length == 0) {
        /* forcing the clean up of hovered items */
        this.hover = null;
        this.$.boardViewer.setHover();

        this.active = this.boardInfo;
        this.updateRoute(this.board, selected, null);
        return;
      }

      var active = null;

      /* Comparing selected set with all category lists */
      var isCategory = false;
      for (var i = 0; i < this.categories.length; i++) {
        /* If the current selection is the same list as a defined category list,
         * Then we assume that is a category interaction. */
        if (this.categories[i].list == selected) {
          isCategory = true;
          break;
        }
      }

      if (isCategory && this.category) {
        /* Selecting category button */
        var el = this.$.layout.querySelector("paper-button[match='" + this.category.slug + "']");
        if (el) {
          this._enableItemButtons({
            refdes: this.category.slug
          });
        }

        this.active = this.boardInfo;
        this.updateRoute(this.board, [], this.category);
        return;
      }

      /* Walk through the list of selected items and enable them in the
       * keywords and components */
      selected.forEach(function(refdes) {
        /* Check if it is a component/pin... */
        var item = this.$.boardViewer.findComponent(refdes);
        /* Try to find if is a keyword. */
        if (!item && this.isKeyword(refdes)) {
          item = { refdes: refdes };
        }

        /* If the first non-keyword hasn't been set, set it to this item */
        if (!active) {
          active = item;
        }

        this._enableItemButtons(item);

        /* If the item is part of a component, enable the component too */
        if (item.component) {
          this._enableItemButtons(this.$.boardViewer.findComponent(item.component));
        }
      }.bind(this));

      /* Set the active documentation to either the first non-keyword, or if
       * non are in the selected list, set it to the boardInfo. */
      this.active = active || this.boardInfo;
      this.updateRoute(this.board, selected, null);
    },

    _getItemNamesAndContexts: function(item) {
      /* If no item is set, there is no name */
      if (!item) {
        return [];
      }

      /* If this item has defined its own context, return it */
      if ("context" in item && typeof item.context === "string") {
        return [ { context: item.context, name: item.name } ];
      }

      /* If the item is not within a component, then
       * there are no contexts; return just "default" */
      if (!item.component) {
        return [ { context: "Generic name", name: item.name } ];
      }

      var NaCs = [],
        component = this.$.boardViewer.getInfo(item.component);

      /* If there are no contexts, return just "default" */
      if (!component || !component.contexts) {
        return [ { context: "Generic name", name: item.name } ];
      }

      for (var i = 0; i < component.contexts.length; i++) {
        /* `name` can either be a single entry, or an array of names for
         * each context. If a context does not have a specific name, N/A is
         * provided */
        NaCs.push({
          context: component.contexts[i],
          name: Array.isArray(item.name) ?
            ((typeof item.name[i] === "string") ? item.name[i] : "N/A") : /* If a context slot is missing, N/A */
            (i == 0 ? item.name : "N/A") /* A single name is only provided for the first context */
        });
      }
      return NaCs;
    },

    _searchModeChanged: function(searchMode) {
      console.log("Mode changed to " + searchMode);

      //this.$.boardViewer.selected = [];
      //this.$.boardViewer.setHover();

      if (searchMode == "searchPage") {
        this.$.search.value = "";
        this.$.search.focus();
      } else {
        console.log("Setting focus to " + searchMode);
        this.$.searchTabs.querySelector("[name='" + searchMode + "']").focus();
      }

      var searchTabs = Polymer.dom(this.root).querySelectorAll('[control]');
      for (var i = 0; i < searchTabs.length; i++) {
        var attr = searchTabs[i].getAttribute('control');
        searchTabs[i].hidden = (attr == event.detail.value) ? false : true;
      }

      this.onPanelLeftResize();
    },

    hideSelector: function(board, initialized) {
      return !this.isEmpty(board) || !initialized;
    },

    hideReadable: function(item) {
      return !item || this.isEmpty(item.readable) ||  item.readable == item.name;
    },

    unloadBoard: function() {

      /* Force to close drawer in mobile layout. */
      if (this.isMobileLayout) {
        this.$.drawer.close();
      }

      /* If singleBoard is set, clear the selection and stay on board */
      if (this.singleBoard) {
        this.selected = [];
        this.$.boardViewer.setSelected(this.selected);
        this.updateRoute(this.board, this.selected, null);
        return;
      }

      this.$.boardViewer.loadBoard();
      /* Remove all selected */
      this.selected = [];
      this.$.boardViewer.setSelected(this.selected);
      this.category = null;
      this.updateRoute(this.board, this.selected, null);
    },

    itemClassList: function(item) {
      var name = item ? item.name : null;
      if (name && name != item.readable) {
        return "item-with-name";
      }
      return "";
    },

    itemRefDes: function(item) {
      return item.readable || item.refdes || "";
    },

    itemDescription: function(item) {
      return item.description || "";
    },

    itemName: function(item) {
      if (item.name && Array.isArray(item.name)) {
        return item.name.filter(function(name) {
          return name;
        }).join(",");
      }
      return item.name || item.readable || item.refdes || "";
    },

    lookupName: function(refdes) {
      var item = this.$.boardViewer.findComponent(refdes);
      if (!item) {
        return refdes;
      }
      return this.itemRefDes(item);
    },

    isEmpty: function(/*item0, ... */) {
      /* If all parameters passed are empty, return true */
      for (var i = 0; i < arguments.length; i++) {
        var item = arguments[i];
        if (item
          && (!Array.isArray(item) || item.length != 0)
          && item != null
          && item != "") {
          return false;
        }
      }

      return true;
    },

    getBoardBoxTitle: function(name) {
      if (!name) {
        return;
      }

      for (var i = 0; i < this.boards.length; i++) {
        if (this.boards[i].directory == name) {
          return this.boards[i].name;
        }
      }
    },

    getDocumentation: function(item, type) {
      return new Promise(function(resolve, reject) {
        if (item.html) {
          return resolve({
            status: 200,
            content: item.html
          });
        }

        this.$.boardViewer.getDocumentation(item.refdes, type, function(results) {
          if (!results || results.error) {
            if (results.status == 400) {
              return resolve({status: 400});
            }
            return reject(new Error(results.error));
          }

          return resolve(results);
        });
      }.bind(this));
    },

    loadingQueue: function(item) {
      /* If there is already a load in progress, set the next load
       * to this item */
      if (this.loading) {
        this.loading = item;
        return;
      }

      /* Load this item */
      this.loading = item;

      this.getDocumentation(item, "HTML").then(function(item, results) {
        if (results.status == 200) {
          return results.content;
        }

        if (results.status != 400) {
          return Promise.reject(new Error("Error returned from getDocumentation"));
        }

        /* If this is a keyword and there is no content, don't return anything */
        if (this.isKeyword(item.refdes)) {
          return "";
        }

        /* If there was no content, and there is a parent component,
         * and the current hover item is still the one being fetched,
         * fetch the documentation for the parent component and set this
         * item's content to that */
        if (!item.component) {
          return "<p>No additional documentation for " + this.itemRefDes(item);
        }

        var component = this.$.boardViewer.findComponent(item.component);

        /* If the current active item is no longer this one, do not chain
        * to lookup the component's documentation. */
        if (!component.html && this.active != item) {
          return Promise.reject();
        }

        if (component.html) {
          return "<p>Documentation for containing component " + item.component + ": " +
            "<p>" + component.html;
        }

        return this.getDocumentation(component, "HTML").then(function(item, results) {
          if (results.status == 200) {
            /* Set the component's html so it doesn't get fetched again */
            component.html = results.content;

            /* Set the item's documentation to indicate it is the doc for the
             * containing component */
            return "<p>Documentation for containing component " + item.component + ": " +
                "<p>" + results.content;
          }

          /* If it wasn't a 400, there was an error fetching the content */
          if (results.status != 400) {
            return Promise.reject(new Error("Error returned from getDocumentation"));
          }

          /* Return "no additional content"... */
          return "<p>No additional documentation for " + this.itemRefDes(item);
        }.bind(this, item));
      }.bind(this, item)).then(function(item, html) {
        var info = "";

        /* If the item being looked up is a keyword, postfix the keyword
         * item index */
        if (this.isKeyword(item.refdes)) {
          var items = this.$.boardViewer.getItemsByKeyword(item.refdes);
          if (items && items.length) {
            var component = null;

            info += "<h2>Items tagged with '<b>"+item.refdes+"</b>'</h2>";

            items.forEach(function(item) {
              if (component && item.type == "component") {
                info += "</table>";
              }

              if (!component || item.type == "component") {
                info += "<table class='keyword-index'>";
                component = item;
              }

              var names = this._getItemNamesAndContexts(item);

              if (item.type == "component") {
                info += "<thead>";
              }

              info += "<tr>";
              info += "<td><a href='#" + this.board + "/" + item.refdes + "'>" +
                item.readable + "</a></td>";
              names.forEach(function(name) {
                var span = "";
                if (names.length == 1) {
                  span = "colspan='100'";
                }
                info += "<td " + span + ">" + name.context + ": " + name.name + "</td>";
              });
              info += "</tr>";

              if (item.type == "component") {
                info += "</thead>";
              }

            }.bind(this));
            info += "</table>";
          }
        }

        item.html = html + info;
      }.bind(this, item)).catch(function(item, error) {
        /* On error, set the item's HTML to "No additional documentation..." */
        item.html = "<p>No additional documentation for " + this.itemRefDes(item);
      }.bind(this, item)).then(function(item) {
        /* If this is the item currently being hovered on, notify the UI
         * to update the DOM */
        if (this.$.boardViewer.selected.length &&
            this.$.boardViewer.selected[0].toUpperCase() == item.refdes.toUpperCase()) {
          Polymer.dom(this.$.documentation).innerHTML = item.html;
        }

        self = this;
        Array.prototype.forEach.call(this.$.info.querySelectorAll('a[href^="#' + this.board + '"]'), function(el) {
          el.addEventListener('mouseover', self.onAnchorHoverIn.bind(self));
          el.addEventListener('mouseout', self.onAnchorHoverOut.bind(self));
        });

        /* Fire off the most recent load request if it changed while the above
         * was resolving */
        if (this.loading != item) {
          item = this.loading;
          this.loading = null;
          if (item) {
            this.loadingQueue(item);
          }
        } else {
          this.loading = null;
        }
      }.bind(this, item));
    },

    onBoardItemHover: function(event) {
      var info = event.detail,
        item = this.$.boardViewer.findComponent(info.refdes),
        categories = [], el;

      if (!item) {
        return;
      }

      /* Getting owner categories for the item refdes. */
      for (var i = 0; i < this.categories.length; i++) {
        if (this.categories[i].list.indexOf(item.refdes) != -1
          || this.categories[i].list.indexOf(item.component) != -1) {
          categories.push(this.categories[i].slug);
        }
      }

      Array.prototype.forEach.call(this.querySelectorAll("paper-button.hover"),
          function(el) {
        el.classList.remove("hover");
      });

      /* If the direction is IN, add "hover" to all KEYWORDs for this item */
      if (info.in) {
        if (item.keywords) {
          item.keywords.forEach(function(keyword) {
            el = this.$.keywordsPage.querySelector("paper-button[match='" + keyword + "']");
            if (el) {
              el.classList.add("hover");
            }
          }.bind(this));
        }

        /* Adding hover class to all category buttons, if the refdes belongs to,
         * at least one .*/
        if (categories) {
          categories.forEach(function(slug) {
            el = this.$.categoriesPage.querySelector("paper-button[match='" + slug + "']");
            if (el) {
              el.classList.add("hover");
            }
          }.bind(this));
        }
      }

      /* If a pin is being hovered over in the board-viewer, then set the
       * pin's containing component as the active button hover */
      if (item.component && info.source == "board-viewer") {
        info.refdes = item.component;
      }

      this._panelScroll(info);
      /* Leaving an item */
      if (!info.in && this.hover == item) {
        /* If the direction is "OUT" and the hover is currently looking at
         * the item being left, clear the "hover" */
        this.hover = null; /* Force DOM update */

        return;
      }

      this.hover = item;
    },

    /* The following scroll code was derived from
     * https://github.com/PolymerElements/paper-scroll-header-panel/blob/master/paper-scroll-header-panel.html
     * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
     */

     /**
     * Scroll to a specific y coordinate.
     *
     * @method scroll
     * @param {number} top The coordinate to scroll to, along the y-axis.
     * @param {boolean} smooth true if the scroll position should be smoothly adjusted.
     */
    scroll: function(top, smooth) {
      // the scroll event will trigger _updateScrollState directly,
      // However, _updateScrollState relies on the previous `scrollTop` to update the states.
      // Calling _updateScrollState will ensure that the states are synced correctly.
      if (smooth) {
        // TODO(blasten): use CSS scroll-behavior once it ships in Chrome.
        var easingFn = function easeOutQuad(t, b, c, d) {
          t /= d;
          return -c * t*(t-2) + b;
        };
        var animationId = Math.random();
        var duration = 200;
        var startTime = Date.now();
        var currentScrollTop = this.$["panel-left"].scrollTop;
        var deltaScrollTop = top - currentScrollTop;
        this._currentAnimationId = animationId;
        (function updateFrame() {
          var now = Date.now();
          var elapsedTime = now - startTime;
          if (elapsedTime > duration) {
            this.$["panel-left"].scrollTop = top;
            this._updateScrollState(top);
          } else if (this._currentAnimationId === animationId) {
            this.$["panel-left"].scrollTop = easingFn(elapsedTime, currentScrollTop, deltaScrollTop, duration);
            requestAnimationFrame(updateFrame.bind(this));
          }
        }).call(this);
      } else {
        this.$["panel-left"].scrollTop = top;
        this._updateScrollState(top);
      }
    },
    /**
     * Scroll to the top of the content.
     *
     * @method scrollToTop
     * @param {boolean} smooth true if the scroll position should be smoothly adjusted.
     */
    scrollToTop: function(smooth) {
      this.scroll(0, smooth);
    },
    /** @param {Event=} event */
    _scroll: function(event) {
      this._updateScrollState(this.$["panel-left"].scrollTop);
      this.fire('content-scroll', {
        target: this.$["panel-left"]
      }, {
        cancelable: false
      });
    },
    _updateScrollState: function(scrollTop) {
      var deltaScrollTop = scrollTop - this._prevScrollTop,
        y = Math.max(0, scrollTop);
      this._prevScrollTop = Math.max(scrollTop, 0);
      this._y = y;
    },

    onAnchorHoverIn: function(event) {
      var href  = event.target.href;
      var refdes = href.split("/").pop();
      var component  = this.$.boardViewer.findComponent(refdes);
      var options = {
        refdes: refdes,
        source: "board-viewer",
        in: true
      };

      if (component) {
        options.type = 'component';
      }
      else if (this.isKeyword(refdes)) {
        options.type ='keyword';
      }

      this.$.boardViewer.setHover(options);
    },

    onAnchorHoverOut: function(event) {
      var href  = event.target.href;
      var refdes = href.split("/").pop();
      var component  = this.$.boardViewer.findComponent(refdes);
      var options = {
        refdes: refdes,
        source: "board-viewer",
        in: false
      }

      if (component) {
        options.type = 'component';
      }
      else if (this.isKeyword(refdes)) {
        options.type = 'keyword';
      }

      this.$.boardViewer.setHover(options);
    },

    boardTap: function(event) {
      var board = event.model.item.directory;
      console.log("Loading " + board);
      /* Remove all selected */
      this.selected = [];
      this.$.boardViewer.setSelected(this.selected);
      if (this.$.boardViewer.board != board) {
        console.log("Loading board via boardTap");
        this.$.boardViewer.loadBoard(board);
      }
      this.updateRoute(board, this.selected, null);
    },

    onBoardChanged: function(event) {
      var board = event.detail.value || "";

      this.active = null;
      this.hover = null;

      this.board = board;
      this.keywords = [];
      this.pins = [];
      this.components = [];
      this.categories = [];

      if (!board) {
        console.log("Board Explorer unloaded board.");
        return;
      }
      this.boardLoaded();
    },

    boardLoaded: function() {
      console.log("Board Explorer has a board loaded and ready.");
      /* If a board has been set, the app is initialized */
      this.initialized = true;

      this.boardInfo = {
        context: "",
        name: this.board,
        html: "No description of " + this.board + " available."
      };

      for (var i = 0; i < this.boards.length; i++) {
        if (this.boards[i].directory === this.board) {
          this.boardInfo.name = this.boards[i].name;
          break;
        }
      }

      console.log("Asking for keywords...");
      var keywords = [];
      this.$.boardViewer.getKeywords().forEach(function(keyword) {
        keywords.push({
          type: "keyword",
          refdes: keyword
        });
      });
      this.keywords = keywords;

      console.log("Asking for components...");
      var components = [];
      this.$.boardViewer.getComponents().forEach(function(refdes) {
        components.push(this.$.boardViewer.getInfo(refdes));
      }.bind(this));

      this.components = components;
      this.categories = this.$.boardViewer.getCategories();

      /* When the application loads, the default filter is set as follows:
       * 1. If a category is set, searchMode == "categories"
       * 2. If a keyword is set, searchMode == "keywords"
       * 3. searchMode == "components"
       */

      /* If there are categories for this board, select the 'Categories' radio box */
      if (this.category) {
        this.searchMode = "categoriesPage";
        this.$.searchTabs.select('categoriesPage');
      } else if (this.keyword) {
        this.searchMode = "keywordsPage";
      } else {
        this.searchMode = "componentsPage";
      }

      if (!this.active) {
        Polymer.dom(this.$.documentation).innerHTML = "Loading...";
      }

      /* Load the board top-level documentation */
      this.$.boardViewer.getDocumentation(null, "HTML", function(results) {
        if (!results || results.error) {
          console.log(results.error);
          return;
        }

        this.boardInfo.html = results.content;

        /* If nothing else is active, set the active to the boardInfo
         * If something is active, and the active item is the boardInfo,
         * then set the "documentation" directly here since the change
         * won't be detected automatically */
        if (!this.active) {
          this.active = this.boardInfo;
        } else if (this.active == this.boardInfo) {
          Polymer.dom(this.$.documentation).innerHTML = results.content;
        }
      }.bind(this));

      /* After everything has loaded and is initialized, *then* set the active
       * selection */
      if (this.selectedOnceLoaded) {

        var category = this.$.boardViewer.findCategory(this.selectedOnceLoaded[0]);
        if (category) {
          for (var i = 0; i < this.categories.length; i++) {
            if (this.categories[i].refdes == this.selectedOnceLoaded[0].toLowerCase()) {
              this.$.searchTabs.select('categoriesPage');
              this.set("categories." + i + ".selected", true);
              console.log(this.categories[i]);
              this.category = category;
              this.selected = category.list;
            }
          }

        }
        else {
          if (this.isKeyword(this.selectedOnceLoaded[0])) {
            this.$.searchTabs.select('keywordsPage');
            this.keywords[i].selected = true;
          }

          for (var i = 0; i < this.components.length; i++) {
            for (var j = 0; j < this.selectedOnceLoaded.length; j++) {
              if (this.components[i].refdes == this.selectedOnceLoaded[j]) {
                this.components[i].selected = true;
              }
            }
          }
          this.selected = this.selectedOnceLoaded;
        }
        delete this.selectedOnceLoaded;
      }
      /* After the categories, components, or search results change, trigger
       * a re-layout of the left-panel */
      Polymer.dom.flush();
      this.onPanelLeftResize();
    },

    _panelScroll: function(info) {
      /* Toggle the "hover" state for the item and scroll it into view */
      if (this.$[this.searchMode] && info) {
        /* Toggle the "hover" state for the item and scroll it into view */
        var el = this.$[this.searchMode].querySelector("paper-button[match='" + info.refdes + "']");
        if (el) {
          el.classList.toggle("hover", info.in);
          if (info.in && info.source == "board-viewer") {
            var panel = this.$["panel-left"],
              top = panel.scrollTop,
              offset = el.getBoundingClientRect().top;

            /* If the element is above the top of the viewport scroll the viewport,
             * to have the element at the top of the viewport. */
            if (offset < 8) {
              top += offset - 8;
            }
            /* Otherwise, if the bottom of the element is below the viewport
             * scroll the viewport, to have the element justified to the bottom
             * the viewport. */
            else if (offset + el.offsetHeight + 8 > panel.clientHeight) {
              top = top + offset - (panel.clientHeight - el.offsetHeight) + 8;
            }
            this.scroll(top, true);
          }
        }
      }
    },

    isKeyword: function(refdes) {
      var keyword = null;
      for (var j = 0; !keyword && j < this.keywords.length; j++) {
        if (this.keywords[j].refdes == refdes) {
          keyword = refdes;
        }
      }
      return keyword;
    },

    updateRoute: function(board, selected, category) {
      /* Start with an empty route by trimming the hash parameters */
      var href = window.location.href.replace(/#.*/, ""),
        params = [];
      /* If the board is set, add it to the URL */
      if (board) {
         href += "#" + board;

        /* If the filters are set, add them to the URL */
        if (board && selected && selected.length) {
          for (var i = 0; i < selected.length; i++) {

            if (this.$.boardViewer.findComponent(selected[i])) {
              params.push(selected[i]);
              continue;
            }

            if (this.isKeyword(selected[i])) {
              params.push(this.isKeyword(selected[i]));
              continue;
            }

            console.log("Dropping invalid selection: " + selected[i]);
          }
        }

        /* If there is a category set, add it to the first part of the URL */
        if (category) {
          params.unshift(category.slug);
        }

        if (params.length) {
          href += "/" + params.join(",");
        }
      }

      /* If the URL is changing, push it to the window history *IFF* there are
       * not pending selections (if there are, a board is actively loading) */
      if (href != window.location.href && !this.selectedOnceLoaded) {
        /* Add an entry to the window.history to update the URL with the list
         * of active filters */
        window.history.pushState({
          board: board,
          category: category ? category.slug : null,
          selected: selected ? selected.slice() : [] /* Copy of selected array */
        }, board, href);
      }
    },

    buttonTap: function(event) {
      event.preventDefault();

      var refdes = event.model.item.refdes,
        category = this.$.boardViewer.findCategory(refdes),
        index = this.selected.indexOf(refdes);

      /* If we get a category */
      if (category) {
        /* If category get is not the same as the category alreadey set,
         * then is a new active category */
        if (this.category != category) {
          this.category = category;
          this.selected = category.list;

          if (this.isMobileLayout) {
            this.$.drawer.toggle();
          }

          return;
        }
        /* Otherwise we need to remove it */
        if (this.category == category) {
          this.category = null;
          this.selected = [];

          if (this.isMobileLayout) {
            this.$.drawer.toggle();
          }

          return;
        }
      }

      if (!category) {
        this.category = null;
        if (index == -1) {
          this.selected = [ event.model.item.refdes ];
        } else {
          this.selected.splice(index, 1);
          this.$.boardViewer.setSelected(this.selected);
          this.updateRoute(this.board, this.selected, null);
        }

        if (this.isMobileLayout) {
          this.$.drawer.toggle();
        }

      }
    },

    buttonOver: function(event) {
      event.preventDefault();
      this.$.boardViewer.setHover({
        type: event.model.item.type,
        refdes: event.model.item.refdes,
        in: true
      });
    },

    buttonOut: function(event) {
      event.preventDefault();
      this.$.boardViewer.setHover({
        type: event.model.item.type,
        refdes: event.model.item.refdes,
        in: false
      });
    },

    onHashChange: function(event) {
      if (window.location.hash && this.hash != window.location.hash) {
        this.hash = window.location.hash;
      }
    },

    onPopState: function(event) {
      if (!event.state || !event.state.board) {
        this.hash = window.location.hash;
        return;
      }

      this.board = event.state.board;
      this.selected = event.state.selected;
      this.$.boardViewer.setSelected(this.selected);
      if (this.board != this.$.boardViewer.board) {
        console.log("Loading board via popstate: " + this.board);
        this.$.boardViewer.loadBoard(this.board);
      }
      this.updateRoute(this.board, this.selected, null);
    },

    setBoardAndSelectedFromHash: function(boards, hash) {
      var uri = hash.split("/"),
        boardToLoad = null,
        hash = uri[0].substr(1); /* Prune the # */

      /* If we have a category we stored while are not categories loaded yet. */
      if (uri[2]) {
        this.slug = uri[1];
        uri[1] = uri[2];
        uri.splice(2,1);
      }

      /* If single-board override is in effect, only load the single board
       * and ignore the hash portion of the URL ... */
      if (this.singleBoard) {
        boardToLoad = this.singleBoard;
      } else {
        for (var i = 0; i < this.boards.length; i++) {
          if (this.boards[i].directory == hash) {
            boardToLoad = this.boards[i].directory;
            break;
          }
        }
      }

      if (!boardToLoad) {
        this.selected = [];
        this.$.boardViewer.setSelected(this.selected);
        this.board = "";
        /* If the boards.json has loaded, and no board is going to be loaded,
         * the app is initialized; show the board selector */
         if (!this.isEmpty(this.boards)) {
           this.initialized = true;
           console.log("Initialized to board-selector");
         }

         return;
      }


      // Get selected from the url if there are some.
      if (uri[1]) {
        var tokens = uri[1].split(",");
        for (var i = 0; i < tokens.length; i++) {
          tokens[i] = tokens[i].toUpperCase();
        }
        this.selected = tokens;
      } else {
        this.selected = [];
      }

      if (boardToLoad != this.$.boardViewer.board) {
        console.log("Loading board via setBoardAndSelectedFromHash: " + boardToLoad);
        this.selectedOnceLoaded = this.selected;
        this.$.boardViewer.loadBoard(boardToLoad);
      }

      this.$.boardViewer.setSelected(this.selected);
      this.updateRoute(boardToLoad, this.selected, null);
    },

    attached: function() {

      window.addEventListener("popstate", this.onPopState.bind(this));
      window.addEventListener("hashchange", this.onHashChange.bind(this));

      this.$.boardViewer.getBoards(function(boards) {
        if (!boards || boards instanceof Error) {
          this.initialized = true;
          console.log("Initialized to board-selector with no boards.");
          this.$['board-list'].innerHTML = "<div>No boards available to list.</div>";
          window.location.hash = "";
          boards = [];
        }
        this.boards = boards;
        this.hash = window.location.hash;
      }.bind(this));
    }
  });

});
</script>
</dom-module>
</html>
