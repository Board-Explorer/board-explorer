<!doctype html>
<!--
@license
Copyright (C) 2017 Intel Corporation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<html>
<head>
  <link rel="import" href="../../bower_components/polymer/polymer.html">

  <link rel="import" href="../../bower_components/app-layout/app-drawer/app-drawer.html">

  <link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
  <link rel="import" href="../../bower_components/iron-icons/iron-icons.html">
  <link rel="import" href="../../bower_components/iron-icon/iron-icon.html">
  <link rel="import" href="../../bower_components/iron-media-query/iron-media-query.html">
  <link rel="import" href="../../bower_components/iron-pages/iron-pages.html">
  <link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">

  <link rel="import" href="../../bower_components/paper-button/paper-button.html">
  <link rel="import" href="../../bower_components/paper-dropdown-menu/paper-dropdown-menu.html">
  <link rel="import" href="../../bower_components/paper-input/paper-input.html">
  <link rel="import" href="../../bower_components/paper-item/paper-item.html">
  <link rel="import" href="../../bower_components/paper-listbox/paper-listbox.html">
  <link rel="import" href="../../bower_components/paper-material/paper-material.html">
  <link rel="import" href="../../bower_components/paper-tabs/paper-tabs.html">
  <link rel="import" href="../../bower_components/paper-tabs/paper-tab.html">
  <link rel="import" href="../../bower_components/paper-toolbar/paper-toolbar.html">

  <link rel="import" href="../../bower_components/vaadin-split-layout/vaadin-split-layout.html">

  <link rel="import" href="../../bower_components/board-viewer/board-viewer.html">

  <script src="../../bower_components/highlightjs/highlight.pack.min.js"></script>

  <link rel="stylesheet" href="../../bower_components/highlightjs/styles/atom-one-light.css">

  <!--
  `<board-explorer-app>` Provides a container for the board-viewer.

  The board-explorer loads the board-viewer and displays additional selection
  elements for interacting with the board-viewer. It also provides an area
  to render the documentation for a given item (via board-viewer::getDocumentation)

  @demo demo/index.html Simple demo showing a statically loaded view.
  -->

</head>

<dom-module id="board-explorer-app">
<template>
  <style include="iron-flex iron-flex-alignment iron-positioning">
    :host {
      /* Used in board-viewer tab header */
      --focus-foreground-color: #52595a;
      --focus-background-color: #d6eab0;
      --focus-border-color: #97ca41;
      --blur-foreground-color: #52595a;
      --blur-background-color: #f8f8f1;
      --blur-border-color: #f0efe0;
      --bg-l: #f8f8f1;
    }

    #boardTitle {
      cursor: pointer;
    }

    #mobileHeader {
      display: flex;
      height: 15%;
      max-height: 15%;
    }

    #mobileHeader paper-material {
      width: 100%;
      margin-left: 18px;
    }

    #mobileHeader div {
      height: 10%;
      cursor: pointer;
      float: left;
      margin-top: -8px;
    }

    #mobileHeader #boardTitle{
      margin-left: 50px;
      width: 85%;
      font-size: 0.9em;
      margin-top: 0px !important;
    }

    app-drawer {
      background: white;
      overflow: auto;
      z-index: 1;
      top: 13%;
      bottom: 0;
      --app-drawer-width: 100%;
      --app-drawer-scrim-background: rgb(255, 255, 255);
      --app-drawer-content-container: {
        padding: 0 !important;
      }
    }

    board-viewer {
      position: relative;
      height: 480px;
    }

    #drawer #sidebar-left {
      position: absolute;
      top: 0;
      left: 0;
      padding: 120px 0;
    }

    #layout paper-button {
      cursor: pointer;
      display: inline-block;
      box-sizing: border-box;
      padding: 0.25em 0.5em;
      margin: 0.25em 0.5em;
      border-radius: 6px;
      border: 1px solid rgba(0, 0, 0, 0.5);
      min-width: 8em;
      text-decoration: none;
      background-color: #f0f0f0;
      color: black;
      font-size: 1em;
      min-height: 2.2em;
      overflow: hidden;
      text-overflow: ellipsis;
      word-wrap: break-word;
    }

    #layout paper-button[disabled] {
      border-style: dashed;
      color: #888;
    }

    #layout paper-button.hover,
    #layout paper-button:hover {
      background-color: #404040;
      border-color: #00ffff;
      color: #00ffff;
    }

    #layout paper-button.connected {
      border-color: #ff8000;
      color: #ff8000;
      background-color: #888;
    }

    #layout paper-button.related {
      border-color: #00ff00;
      color: #00ff00;
      background-color: #888;
    }

    #layout paper-button.active {
      background-color: #e0e0e0;
    }

    #layout paper-button.item-with-name div:first-child {
      padding-top: 0.3em;
      font-size: 0.8em;
      line-height: 0.8em;
    }

    #layout paper-button.item-with-name div:last-child {
      box-sizing: border-box;
      padding-top: 0.3em;
      font-size: 0.9em;
    }

    #layout paper-button:not(.item-with-name) div:first-child {
      line-height: 2.1em;
    }

    paper-material {
      margin: 0.5em;
      padding: 1em;
    }

    .info-content {
      margin: 1em;
    }

    .info-content a {
      margin-right: 0.25em;
    }

    paper-toolbar {
      --paper-toolbar-background: #f0f0f0;
      --paper-toolbar-color: #444;
      --paper-toolbar-sm-height: 64px;
      padding: 0;
      margin: 0;
      -webkit-transition: 0.15s all ease;
      transition: 0.15s all ease;
    }

    paper-dropdown-menu {
      width: 100%;
    }

    #tooltip {
      position: absolute;
      left: 0px;
      right: 0px;
      margin: -64px 32px auto 32px;
      padding: 4px 16px;
      box-shadow: 0px 3px 3px rgba(64, 64, 64, 0.25);
      box-sizing: border-box;
      font-size: 10pt;
      background-color: rgba(64, 64, 64, 0.5);
      color: #fff;
      pointer-events: none;
    }

    /* NOTE: For this to not horribly squash image aspect ratios, we have
     * the item width hard coded to fixed pixels. We could use various
     * image-fill css attributes, but then we might letterbox the wrong
     * part of the image... */
    .board-card {
      width: 320px;
      cursor: pointer;
      border: 3px solid rgba(255, 255, 255, 0);
      padding: 1rem;
      margin: 0.25rem;
    }

    .board-card > * {
    }

    .board-card:not(.filler) {
      @apply(--board-selector-item-theme);
    }

    .board-card:hover:not(.filler) {
      background-color: #d0e8f8;
    }

    /* fill up the space of the last row */
    .filler {
      dispaly: inline-block;
      width: 320px;
      height: 1px;
      max-height: 1px;
      pointer-events: none;
      margin: 0.25rem;
    }

    .filler.tiny,
    .board-card.tiny {
      width: 100%;
    }

    .board-card .title {
      margin: 0.5em 0;
      width: 100%; /* Fix IE not wrapping text in the paper-button */
    }

    .board-card .image {
      position: relative;
      width: 100%;
      height: calc(240px - 2rem);
      background-size: contain;
      background-position: 50% 50%;
      background-repeat: no-repeat;
    }

    #board-selector .heading {
      margin: 0 0 0.5em 0;
      font-weight: bold;
    }

    #board-selector paper-button {
      margin: 0.5em;
    }

    #documentation table {
      padding: 0px;
      margin: 0px;
      border-spacing: 0px;
    }

    #documentation th,
    #documentation td {
      border-right: 1px solid black;
      padding: 0 0.5em;
    }

    #documentation th {
      border-bottom: 1px solid black;
    }

    #documentation th:last-child,
    #documentation td:last-child {
      border-right: 1px none black;
    }

    #layout {
      height: 100%;
      max-height: 100%;
    }

    #vaadin-container {
      height: 100%;
    }

    #layout.mobile {
      height: 87%;
      max-height: 87%;
      margin-left: -10px;
    }

    #sidebar-left {
      width: 100%;
      max-width: 100%;
    }

    #panel-left {
      width: 33.3%;
      overflow: auto;
      min-width: 250px;
    }

    #panel-left.constrained {
      font-size: 0.8em;
    }

    #panel-left.constrained paper-tab {
      --paper-tab: {
        font-size: 0.8em;
      };
    }

    #panel-right {
      width: 66.7%;
      max-width: 100%;
    }

    #panel-bottom {
      height: 33.3%;
    }

    /* Fix IE not wrapping correctly in flex wrap layouts */
    .wrap {
      width: 100%;
    }

    .context-and-name {
      margin-right: 0.5ex;
    }

    .context-and-name:not(:last-of-type):not(:first-of-type) {
      padding-right: 0.5ex;
      border-right: 1px solid #d0d0d0;
    }

    .context-and-name div:first-child {
      font-size: 0.75em;
      min-height: 0.75em;
    }

    .context-and-name div:last-child {
      font-size: 1em;
    }

  </style>

  <iron-media-query query="(max-width:480px)" query-matches="{{isMobileLayout}}" on-query-matches-changed="onLayoutChange"></iron-media-query>

  <paper-material id="board-selector" hidden$="[[hideSelector(board,initialized)]]" class="layout vertical start">
    <div class="vertical layout wrap">
      <div class="heading">Select a board to explore</div>
      <div id="board-list" class="layout horizontal start-justified wrap">
        <template is="dom-repeat" items="[[boards]]">
          <paper-button raised noink class="board-card layout vertical" tabindex$="[[index]]" on-tap="boardTap">
            <div class="image" style$="background-image: url('boards/[[item.image]]');">
            </div>
            <div class="title">[[item.name]]</div>
          </paper-button>
        </template>
      </div>
    </div>
  </paper-material>

  <div id="layout" id="layout" hidden$="[[isEmpty(board)]]">

    <div id="mobileHeader" hidden$="{{!isMobileLayout}}">
      <paper-material>
        <div><paper-icon-button icon="menu" slot="dropdown-trigger" alt="menu" on-tap="toggleDrawer"></paper-icon-button></div>
        <div id="boardTitle" on-tap="unloadBoard">[[getBoardBoxTitle(board)]]</div>
      </paper-material>
    </div>

    <app-drawer id="drawer">
      <paper-material class="vertical layout">
        <paper-tabs id="searchTabs" selected="{{searchMode}}" attr-for-selected="name">
          <paper-tab name="searchPage">Search</paper-tab>
          <paper-tab name="categoriesPage" hidden$="[[isEmpty(categories)]]">Categories</paper-tab>
          <paper-tab name="keywordsPage">Keywords</paper-tab>
          <paper-tab name="componentsPage">Components</paper-tab>
          <paper-tab name="overviewPage" hidden>Get to know the board</paper-tab>
        </paper-tabs>
      </paper-material>

      <paper-material class="vertical layout">
        <iron-pages id="pages" selected="[[searchMode]]" attr-for-selected="id">
          <div id="searchPage" class="vertical layout">
            <paper-input id="search" value="{{search}}" label="Search" class="flex">
              <iron-icon suffix slot="suffix" icon="search"></iron-icon>
            </paper-input>
            <div hidden$="[[!isEmpty(search)]]">Enter a string to search (for example "I2C").</div>
            <div hidden$="[[isEmpty(search)]]">
              <div>Search results</div>
              <div hidden$="[[!isEmpty(matches)]]">No matches.</div>
              <div class="layout horizontal wrap">
                <template is="dom-repeat" items="[[matches]]">
                  <paper-button match$="[[item.refdes]]"
                      class="item-with-name layout vertical start"
                      on-tap="buttonTap"
                      on-mouseover="buttonOver"
                      on-mouseout="buttonOut">
                    <div>[[itemName(item)]]</div>
                    <div>[[item.field]]: [[item.value]]</div>
                  </paper-button>
                </template>
              </div>
            </div>
          </div>

          <div id="categoriesPage" class="vertical layout">
            <div>Categories</div>
            <div class="layout horizontal wrap">
              <template is="dom-repeat" items="[[categories]]">
                <paper-button match$="[[item.slug]]"
                    class$="layout vertical start"
                    on-tap="buttonTap"
                    on-mouseover="buttonOver"
                    on-mouseout="buttonOut">
                  <div>[[item.name]]</div>
                  <div></div>
                </paper-button>
              </template>
            </div>
          </div>

          <div id="keywordsPage" class="vertical layout">
            <div>Keywords</div>
            <div class="horizontal layout wrap">
              <template is="dom-repeat" items="[[keywords]]">
                <paper-button match$="[[item.refdes]]"
                    class$="layout vertical start"
                    on-tap="buttonTap"
                    on-mouseover="buttonOver"
                    on-mouseout="buttonOut">
                  <div>[[item.refdes]]</div>
                  <div></div>
                </paper-button>
              </template>
            </div>
          </div>

          <div id="componentsPage" class="vertical layout start">
            <div>Components</div>
            <div class="layout horizontal wrap">
              <template is="dom-repeat" items="[[components]]">
                <paper-button match$="[[item.refdes]]"
                    class$="[[itemClassList(item)]] layout vertical start"
                    on-tap="buttonTap"
                    on-mouseover="buttonOver"
                    on-mouseout="buttonOut">
                  <div>[[itemRefDes(item)]]</div>
                  <template is="dom-if" if="{{itemClassList(item)}}"><div>[[itemName(item)]]</div></template>
                </paper-button>
              </template>
            </div>
          </div>
        </iron-pages>
      </paper-material>
    </app-drawer>

    <vaadin-split-layout class="horizontal layout justified" id="vaadin-container">
      <div id="panel-left" hidden$="{{isMobileLayout}}" class$="[[_panelLeftClass]]">
        <div class="vertical layout flex" id="sidebar-left">
          <paper-material id="boardTitle" on-tap="unloadBoard" class="vertical layout start" hidden$="{{isMobileLayout}}">
            [[getBoardBoxTitle(board)]]
          </paper-material>

          <paper-material class="vertical layout">
            <paper-tabs id="searchTabs" selected="{{searchMode}}" attr-for-selected="name">
              <paper-tab name="searchPage">Search</paper-tab>
              <paper-tab name="categoriesPage" hidden$="[[isEmpty(categories)]]">Categories</paper-tab>
              <paper-tab name="keywordsPage">Keywords</paper-tab>
              <paper-tab name="componentsPage">Components</paper-tab>
              <paper-tab name="overviewPage" hidden>Get to know the board</paper-tab>
            </paper-tabs>
          </paper-material>

          <paper-material class="vertical layout">
            <iron-pages id="pages" selected="[[searchMode]]" attr-for-selected="id">
              <div id="searchPage" class="vertical layout">
                <paper-input id="search" value="{{search}}" label="Search" class="flex">
                  <iron-icon suffix slot="suffix" icon="search"></iron-icon>
                </paper-input>
                <div hidden$="[[!isEmpty(search)]]">Enter a string to search (for example "I2C").</div>
                <div hidden$="[[isEmpty(search)]]">
                  <div>Search results</div>
                  <div hidden$="[[!isEmpty(matches)]]">No matches.</div>
                  <div class="layout horizontal wrap">
                    <template is="dom-repeat" items="[[matches]]">
                      <paper-button match$="[[item.refdes]]"
                          class="item-with-name layout vertical start"
                          on-tap="buttonTap"
                          on-mouseover="buttonOver"
                          on-mouseout="buttonOut">
                        <div>[[itemName(item)]]</div>
                        <div>[[item.field]]: [[item.value]]</div>
                      </paper-button>
                    </template>
                  </div>
                </div>
              </div>

              <div id="categoriesPage" class="vertical layout">
                <div>Categories</div>
                <div class="layout horizontal wrap">
                  <template is="dom-repeat" items="[[categories]]">
                    <paper-button match$="[[item.slug]]"
                        class$="layout vertical start"
                        on-tap="buttonTap"
                        on-mouseover="buttonOver"
                        on-mouseout="buttonOut">
                      <div>[[item.name]]</div>
                      <div></div>
                    </paper-button>
                  </template>
                </div>
              </div>

              <div id="keywordsPage" class="vertical layout">
                <div>Keywords</div>
                <div class="horizontal layout wrap">
                  <template is="dom-repeat" items="[[keywords]]">
                    <paper-button match$="[[item.refdes]]"
                        class$="layout vertical start"
                        on-tap="buttonTap"
                        on-mouseover="buttonOver"
                        on-mouseout="buttonOut">
                      <div>[[item.refdes]]</div>
                      <div></div>
                    </paper-button>
                  </template>
                </div>
              </div>

              <div id="componentsPage" class="vertical layout start">
                <div>Components</div>
                <div class="layout horizontal wrap">
                  <template is="dom-repeat" items="[[components]]">
                    <paper-button match$="[[item.refdes]]"
                        class$="[[itemClassList(item)]] layout vertical start"
                        on-tap="buttonTap"
                        on-mouseover="buttonOver"
                        on-mouseout="buttonOut">
                      <div>[[itemRefDes(item)]]</div>
                      <template is="dom-if" if="{{itemClassList(item)}}"><div>[[itemName(item)]]</div></template>
                    </paper-button>
                  </template>
                </div>
              </div>
            </iron-pages>
          </paper-material>
        </div>
      </div>

      <vaadin-split-layout vertical id="panel-right">
        <board-viewer
          class="flex-grow"
          hidden$="[[isEmpty(board)]]"
          id="boardViewer"
          selected="{{selected}}"
          disable-auto-resize
          enable-zoom
          enable-drag>
        </board-viewer>
        <div id="panel-bottom">
          <div id="tooltip" hidden$="[[isEmpty(hover)]]"
              class$="[[itemClassList(hover)]] horizontal layout">
            <div hidden$="[[hideReadable(hover)]]"
                class="context-and-name layout vertical justified start">
              <div>&nbsp;</div>
              <div>[[hover.readable]]: </div>
            </div>
            <template is="dom-repeat" items="[[_getItemNamesAndContexts(hover)]]">
              <div class="context-and-name layout vertical justified start">
                <div>[[item.context]]</div>
                <div>[[item.name]]</div>
              </div>
            </template>
          </div>
          <div id="info"
            hidden$="[[isEmpty(active)]]"
            class$="[[itemClassList(active)]] vertical layout">
            <paper-toolbar>
              <div hidden$="[[hideReadable(active)]]"
                class="context-and-name layout vertical justified start">
                <div>&nbsp;</div>
                <div>[[active.readable]]: </div>
              </div>
              <template is="dom-repeat" items="[[_getItemNamesAndContexts(active)]]">
                <div class="context-and-name layout vertical justified start">
                  <div>[[item.context]]</div>
                  <div>[[item.name]]</div>
                </div>
              </template>
            </paper-toolbar>
            <div class="info-content">
              <div hidden$="[[isEmpty(active.component)]]">Component: [[active.component]]</div>
              <div hidden$="[[isEmpty(active.pins)]]">Pins: [[active.pins.length]]</div>
              <div hidden$="[[isEmpty(active.keywords)]]">
                Keywords: <template is="dom-repeat" items="[[active.keywords]]" as="keyword">
                  <a href="#[[board]]/[[keyword]]">[[keyword]]</a>
                </template>
              </div>
              <div hidden$="[[isEmpty(active.connected)]]">
                Connected to: <template is="dom-repeat" items="[[active.connected]]" as="refdes">
                  <a href="#[[board]]/[[refdes]]">[[lookupName(refdes)]]</a>
                </template>
              </div>
              <div hidden$="[[isEmpty(active.related)]]">
                Related to: <template is="dom-repeat" items="[[active.related]]" as="refdes">
                  <a href="#[[board]]/[[refdes]]">[[lookupName(refdes)]]</a>
                </template>
              </div>
              <div hidden$="[[isEmpty(active.description)]]">Description: [[active.description]]</div>
              <div><div id="documentation"></div></div>
            </div>
          </div>
        </div>
      </vaadin-split-layout>
    </vaadin-split-layout>
  </div>
</template>
<script>
"use strict";

document.addEventListener("WebComponentsReady", function() {
  Polymer({
    is: "board-explorer-app",
    properties: {
      boards: {
        type: Array,
        value: []
      },
      singleBoard: {
        type: String,
        value: "" /* replace with board-name for single board explorer */
      },
      board: {
        type: String,
        value: null
      },
      /** The currently "active" item, which is either the board itself
       * or the first non-keyword in the board-viewer's "selected" list */
      active: {
        type: Object,
        value: null
      },
      categories: {
        type: Array,
        value: []
      },
      category: {
        type: Object,
        value: null
      },
      slug: {
        type: String,
        value: null
      },
      keywords: {
        type: Array,
        value: []
      },

      selected: {
        type: Array,
        value: []
      },

      /** Array of items which match the search pattern. */
      matches: {
        type: Array,
        value: []
      },

      components: {
        type: Array,
        value: []
      },

      pins: {
        type: Array,
        value: []
      },

      /** Item currently hovered over; used for tool-tip */
      hover: {
        type: Object,
        value: null
      },

      fetching: {
        type: Boolean,
        value: false
      },
      initialized: {
        type: Boolean,
        value: false
      },
      isMobileLayout: {
        type: Boolean,
        value: false
      },

      /** Class to apply to left-panel (used for responsive design) */
      _panelLeftClass: {
        type: String,
        value: ""
      }
    },

    observers: [
      "setBoardAndSelectedFromHash(boards, hash)",
      "_searchModeChanged(searchMode)",
      "_searchChanged(search)",
      "_activeChanged(active)"
    ],

    listeners: {
      "vaadin-container.iron-resize": "onPanelLeftResize",
      "boardViewer.board-changed": "onBoardChanged",
      "boardViewer.item-hover": "onBoardItemHover",
      "boardViewer.selected-changed": "onBoardSelectedChanged",
      "search.focused-changed": "_searchFocus"
    },

    onPanelLeftResize: function(event) {
      this.async(function() {
        if (this.$.panel-left.offsetWidth < 480) {
          this._panelLeftClass = "constrained";
        } else {
          this._panelLeftClass = "";
        }
        this.updateStyles();
      });
    },

    toggleDrawer: function () {
      this.$.drawer.toggle();
    },

    onLayoutChange: function(event) {
      if (event.detail.value) {
        this.$.layout.classList.add('mobile');
      }
      else {
        this.$.layout.classList.remove('mobile');
        this.$.drawer.close();
      }
    },

    _activeChanged: function(active) {
      if (!active) {
        return;
      }

      if (active.html) {
        Polymer.dom(this.$.documentation).innerHTML = active.html;
      } else {
        Polymer.dom(this.$.documentation).innerHTML = "Loading...";
        this.loadingQueue(active);
      }
    },

    /* Callback whenever the Search box changes text */
    _searchChanged: function(search) {
      if (this.isEmpty(search)) {
        this.matches = [];
        return;
      }

      var matches = [],
        regexp = new RegExp(search.replace(/[-^$\\*\/+?().|[\]{}]/g, '\\$&'), "i");

      /* Look into an item and try and match various fields for the search string
       * including keywords, names, etc. */
      function _matchItem(regexp, item) {
        var fields = [ "name", "refdes", "description" ];
        for (var i = 0; i < fields.length; i++) {
          var result = regexp.exec(item[fields[i]]);
          if (!result) {
            continue;
          }
          return {
            type: item.type,
            item: item,
            name: item.name || item.readable || "",
            refdes: item.refdes,
            field: fields[i],
            value: item[fields[i]],
            match: result
          };
        }

        if (item.keywords) {
          for (var i = 0; i < item.keywords.length; i++) {
            var result = regexp.exec(item.keywords[i]);
            if (!result) {
              continue;
            }
            return {
              type: item.type,
              item: item,
              refdes: item.refdes,
              name: item.name || item.readable || "",
              field: "keyword",
              value: item.keywords[i],
              match: result
            };
          }
        }
        return null;
      }

      this.components.forEach(function(item) {
        var match = _matchItem(regexp, item);
        if (match) {
          matches.push(match);
        }

        if (item.pins) {
          item.pins.forEach(function(pin) {
            var match = _matchItem(regexp, pin);
            if (match) {
              matches.push(match);
            }
          });
        }
      });

      this.keywords.forEach(function(item) {
        var result = regexp.exec(item.keyword);
        if (!result) {
          return;
        }
        matches.push({
          type: "keyword",
          field: "keyword",
          refdes: item.keyword,
          keyword: item.keyword,
          value: item.keyword,
          match: result
        });
      });

      this.categories.forEach(function(item) {
        var result = regexp.exec(item.name);
        if (!result) {
          return;
        }
        matches.push({
          type: "category",
          field: "category",
          refdes: item.slug,
          value: item.name,
          slug: item.slug,
          match: result
        });
      });

      this.matches = matches;
    },

    _searchFocus: function(event) {
      if (event.detail.value) {
        this.searchMode = "searchPage";
      }
    },

    _enableItemButtons: function(item) {
      var el;

      if (!item) {
        return;
      }

     Array.prototype.forEach.call(this.$.layout.querySelectorAll("paper-button[match='" + item.refdes + "']"), function(el) {
        el.disabled = false;
      });
    },

    onBoardSelectedChanged: function(event) {
      if (!this.board) {
        return;
      }

      var selected = this.$.boardViewer.selected || [];
      /* If no selection is active, then enable everything and return */
      if (selected.length == 0) {

        Array.prototype.forEach.call(this.$.layout.querySelectorAll("paper-button"), function(el) {
          el.disabled = false;
        });

        this.active = this.boardInfo;
        this.updateRoute(this.board, selected, null);
        return;
      }
      /* Disable all items in the currently viewed page */
      Array.prototype.forEach.call(this.$.layout.querySelectorAll("paper-button"), function(el) {
        el.disabled = true;
      });


      var active = null;

      /* Comparing selected set with all category lists */
      var isCategory = false;
      for (var i = 0; i < this.categories.length; i++) {
        /* If the current selection is the same list as a defined category list,
         * Then we assume that is a category interaction. */
        if (this.categories[i].list == selected) {
          isCategory = true;
          break;
        }
      }

      if (isCategory && this.category) {

        Array.prototype.forEach.call(this.$.layout.querySelectorAll("paper-button[match='"+ this.category.slug +"']"), function(el) {
          el.disabled = true;
        });

        this.active = this.boardInfo;
        this.updateRoute(this.board, [], this.category);
        return;
      }

      /* Walk through the list of selected items and enable them in the
       * keywords and components */
      selected.forEach(function(refdes) {
        /* Disable the button that matches this refdes */
        Array.prototype.forEach.call(this.$.layout.querySelectorAll("paper-button[match='"+ refdes +"']"), function(el) {
          el.disabled = true;
        });

        /* Check if it is a component/pin... */
        var item = this.$.boardViewer.findComponent(refdes);
        if (!item) {
          /* It's a keyword, so return */
          return;
        }

        /* If the first non-keyword hasn't been set, set it to this item */
        if (!active) {
          active = item;
        }

        this._enableItemButtons(item);

        /* If the item is part of a component, enable the component too */
        if (item.component) {
          this._enableItemButtons(this.$.boardViewer.findComponent(item.component));
        }
      }.bind(this));

      /* Set the active documentation to either the first non-keyword, or if
       * non are in the selected list, set it to the boardInfo. */
      this.active = active || this.boardInfo;
      this.updateRoute(this.board, selected, null);
    },

    _getItemNamesAndContexts: function(item) {
      /* If no item is set, there is no name */
      if (!item) {
        return [];
      }

      /* If this item has defined its own context, return it */
      if ("context" in item && typeof item.context === "string") {
        return [ { context: item.context, name: item.name } ];
      }

      /* If the item is not within a component, then
       * there are no contexts; return just "default" */
      if (!item.component) {
        return [ { context: "Generic name", name: item.name } ];
      }

      var NaCs = [],
        component = this.$.boardViewer.getInfo(item.component);

      /* If there are no contexts, return just "default" */
      if (!component || !component.contexts) {
        return [ { context: "Generic name", name: item.name } ];
      }

      for (var i = 0; i < component.contexts.length; i++) {
        /* `name` can either be a single entry, or an array of names for
         * each context. If a context does not have a specific name, N/A is
         * provided */
        NaCs.push({
          context: component.contexts[i],
          name: Array.isArray(item.name) ?
            ((typeof item.name[i] === "string") ? item.name[i] : "N/A") : /* If a context slot is missing, N/A */
            (i == 0 ? item.name : "N/A") /* A single name is only provided for the first context */
        });
      }
      return NaCs;
    },

    _searchModeChanged: function(searchMode) {
      console.log("Mode changed to " + searchMode);

      this.$.boardViewer.selected = [];
      this.$.boardViewer.setHover();

      if (searchMode == "searchPage") {
        this.$.search.value = "";
        this.$.search.focus();
      } else {
        console.log("Setting focus to " + searchMode);
        this.$.searchTabs.querySelector("[name='" + searchMode + "']").focus();
      }

      var searchTabs = Polymer.dom(this.root).querySelectorAll('[control]');
      for (var i = 0; i < searchTabs.length; i++) {
        var attr = searchTabs[i].getAttribute('control');
        searchTabs[i].hidden = (attr == event.detail.value) ? false : true;
      }
    },

    hideSelector: function(board, initialized) {
      return !this.isEmpty(board) || !initialized;
    },

    hideReadable: function(item) {
      return !item || this.isEmpty(item.readable) ||  item.readable == item.name;
    },

    unloadBoard: function() {

      /* Force to close drawer in mobile layout. */
      if (this.isMobileLayout) {
        this.$.drawer.close();
      }

      /* If singleBoard is set, clear the selection and stay on board */
      if (this.singleBoard) {
        this.selected = [];
        this.$.boardViewer.setSelected(this.selected);
        this.updateRoute(this.board, this.selected, null);
        return;
      }

      this.$.boardViewer.loadBoard();
      /* Remove all selected */
      this.selected = [];
      this.$.boardViewer.setSelected(this.selected);
      this.category = null;
      this.updateRoute(this.board, this.selected, null);
    },

    itemClassList: function(item) {
      var name = item ? item.name : null;
      if (name && name != item.readable) {
        return "item-with-name";
      }
      return "";
    },

    itemRefDes: function(item) {
      return item.readable || item.refdes || "";
    },

    itemDescription: function(item) {
      return item.description || "";
    },

    itemName: function(item) {
      return item.name || item.readable || item.refdes || "";
    },

    lookupName: function(refdes) {
      var item = this.$.boardViewer.findComponent(refdes);
      if (!item) {
        return refdes;
      }
      return this.itemRefDes(item);
    },

    isEmpty: function(/*item0, ... */) {
      /* If all parameters passed are empty, return true */
      for (var i = 0; i < arguments.length; i++) {
        var item = arguments[i];
        if (item
          && (!Array.isArray(item) || item.length != 0)
          && item != null
          && item != "") {
          return false;
        }
      }

      return true;
    },

    getBoardBoxTitle: function(name) {
      if (!name) {
        return;
      }

      for (var i = 0; i < this.boards.length; i++) {
        if (this.boards[i].directory == name) {
          return this.boards[i].name;
        }
      }
    },

    getDocumentation: function(item, type) {
      return new Promise(function(resolve, reject) {
        if (item.html) {
          return resolve({
            status: 200,
            content: item.html
          });
        }

        this.$.boardViewer.getDocumentation(item.refdes, type, function(results) {
          if (!results || results.error) {
            if (results.status == 400) {
              return resolve({status: 400});
            }
            return reject(new Error(results.error));
          }

          return resolve(results);
        });
      }.bind(this));
    },

    loadingQueue: function(item) {
      /* If there is already a load in progress, set the next load
       * to this item */
      if (this.loading) {
        this.loading = item;
        return;
      }

      /* Load this item */
      this.loading = item;

      this.getDocumentation(item, "HTML").then(function(item, results) {
        if (results.status == 200) {
          return results.content;
        }

        if (results.status != 400) {
          return Promise.reject(new Error("Error returned from getDocumentation"));
        }

        /* If there was no content, and there is a parent component,
         * and the current hover item is still the one being fetched,
         * fetch the documentation for the parent component and set this
         * item's content to that */
        if (!item.component) {
          return "<p>No additional documentation for " + this.itemRefDes(item);
        }

        var component = this.$.boardViewer.findComponent(item.component);

        /* If the current active item is no longer this one, do not chain
        * to lookup the component's documentation. */
        if (!component.html && this.active != item) {
          return Promise.reject();
        }

        if (component.html) {
          return "<p>Documentation for containing component " + item.component + ": " +
            "<p>" + component.html;
        }

        return promise.then(function(results) {
          if (results.status == 200) {
            /* Set the component's html so it doesn't get fetched again */
            component.html = results.content;

            /* Set the item's documentation to indicate it is the doc for the
             * containing component */
            return "<p>Documentation for containing component " + item.component + ": " +
                "<p>" + results.content;
          }

          /* If it wasn't a 400, there was an error fetching the content */
          if (results.status != 400) {
            return Promise.reject(new Error("Error returned from getDocumentation"));
          }

          /* Return "no additional content"... */
          return "<p>No additional documentation for " + this.itemRefDes(item);
        }.bind(this, item));
      }.bind(this, item)).then(function(item, html) {
        item.html = html;
      }.bind(this, item)).catch(function(item, error) {
        /* On error, set the item's HTML to "No additional documentation..." */
        item.html = "<p>No additional documentation for " + this.itemRefDes(item);
      }.bind(this, item)).then(function(item) {
        /* If this is the item currently being hovered on, notify the UI
         * to update the DOM */
        if (this.$.boardViewer.selected.length &&
            this.$.boardViewer.selected[0] == item.refdes) {
          Polymer.dom(this.$.documentation).innerHTML = item.html;
        }

        self = this;
        Array.prototype.forEach.call(this.$.info.querySelectorAll('a[href^="#' + this.board + '"]'), function(el) {
          el.addEventListener('mouseover', self.onAnchorHoverIn.bind(self));
          el.addEventListener('mouseout', self.onAnchorHoverOut.bind(self));
        });

        /* Fire off the most recent load request if it changed while the above
         * was resolving */
        if (this.loading != item) {
          item = this.loading;
          this.loading = null;
          if (item) {
            this.loadingQueue(item);
          }
        } else {
          this.loading = null;
        }
      }.bind(this, item));
    },

    onBoardItemHover: function(event) {
      var info = event.detail,
        item = this.$.boardViewer.findComponent(info.refdes),
        categories = [], el;

      if (!item) {
        return;
      }

      /* Getting owner categories for the item refdes. */
      for (var i = 0; i < this.categories.length; i++) {
        if (this.categories[i].list.indexOf(item.refdes) != -1
          || this.categories[i].list.indexOf(item.component) != -1) {
          categories.push(this.categories[i].slug);
        }
      }

      Array.prototype.forEach.call(this.querySelectorAll("paper-button.hover"),
          function(el) {
        el.classList.remove("hover");
      });

      /* If the direction is IN, add "hover" to all KEYWORDs for this item */
      if (info.in) {
        if (item.keywords) {
          item.keywords.forEach(function(keyword) {
            el = this.$.keywordsPage.querySelector("paper-button[match='" + keyword + "']");
            if (el) {
              el.classList.add("hover");
            }
          }.bind(this));
        }

        /* Adding hover class to all category buttons, if the refdes belongs to,
         * at least one .*/
        if (categories) {
          categories.forEach(function(slug) {
            el = this.$.categoriesPage.querySelector("paper-button[match='" + slug + "']");
            if (el) {
              el.classList.add("hover");
            }
          }.bind(this));
        }
      }

      /* If a pin is being hovered over in the board-viewer, then set the
       * pin's containing component as the active button hover */
      if (item.component && info.source == "board-viewer") {
        info.refdes = item.component;
      }

      /* Toggle the "hover" state for the item and scroll it into view */
      el = this.$[this.searchMode].querySelector("paper-button[match='" + info.refdes + "']");
      if (el) {
        el.classList.toggle("hover", info.in);
        if (info.in && info.source == "board-viewer") {
          var panel = this.$.layout.querySelector("#panel-left");
          var top = panel.scrollTop;
          /* If the element is above the top of the viewport scroll the viewport,
           * to have the element at the top of the viewport. */
          if (el.offsetTop < top) {
            top = el.offsetTop;
          }
          /* Otherwise, if the element is below the viewport scroll the viewport,
           * to have the element at the bottom of the viewport. */
          else if (el.offsetTop + el.offsetHeight > top + panel.offsetHeight) {
            top = el.offsetTop  + panel.offsetHeight + el.offsetHeight;
          }
          /* If scroll position changed, update it on the panel */
          if (top != panel.scrollTop) {
            panel.scrollTop = top;
          }
        }
      }

      /* Leaving an item */
      if (!info.in && this.hover == item) {
        /* If the direction is "OUT" and the hover is currently looking at
         * the item being left, clear the "hover" */
        this.hover = null; /* Force DOM update */

        return;
      }

      this.hover = item;
    },

    onAnchorHoverIn: function(event) {
      var href  = event.target.href;
      var refdes = href.split("/").pop();
      var component  = this.$.boardViewer.findComponent(refdes);
      if (component) {
        this.$.boardViewer.setHover({
          type: component.type,
          refdes: component.refdes,
          source: "board-viewer",
          in: true
        });
      }
    },

    onAnchorHoverOut: function(event) {
      var href  = event.target.href;
      var refdes = href.split("/").pop();
      var component  = this.$.boardViewer.findComponent(refdes);
      if (component) {
        this.$.boardViewer.setHover({
          type: component.type,
          refdes: component.refdes,
          source: "board-viewer",
          in: false
        });
      }
    },

    boardTap: function(event) {
      var board = event.model.item.directory;
      console.log("Loading " + board);
      /* Remove all selected */
      this.selected = [];
      this.$.boardViewer.setSelected(this.selected);
      if (this.$.boardViewer.board != board) {
        console.log("Loading board via boardTap");
        this.$.boardViewer.loadBoard(board);
      }
      this.updateRoute(board, this.selected, null);
    },

    onBoardChanged: function(event) {
      var board = event.detail.value || "";

      this.active = null;
      this.hover = null;

      this.board = board;
      this.keywords = [];
      this.pins = [];
      this.components = [];
      this.categories = [];

      if (!board) {
        console.log("Board Explorer unloaded board.");
        return;
      }
      this.boardLoaded();
    },

    boardLoaded: function() {
      console.log("Board Explorer has a board loaded and ready.");
      /* If a board has been set, the app is initialized */
      this.initialized = true;

      this.boardInfo = {
        context: "",
        name: this.board,
        html: "No description of " + this.board + " available."
      };

      for (var i = 0; i < this.boards.length; i++) {
        if (this.boards[i].directory === this.board) {
          this.boardInfo.name = this.boards[i].name;
          break;
        }
      }

      console.log("Asking for keywords...");
      var keywords = [];
      this.$.boardViewer.getKeywords().forEach(function(keyword) {
        keywords.push({
          type: "keyword",
          refdes: keyword
        });
      });
      this.keywords = keywords;

      console.log("Asking for components...");
      var components = [];
      this.$.boardViewer.getComponents().forEach(function(refdes) {
        components.push(this.$.boardViewer.getInfo(refdes));
      }.bind(this));

      this.components = components;

      this.categories = this.$.boardViewer.getCategories();

      /* When the application loads, the default filter is set as follows:
       * 1. If a category is set, searchMode == "categories"
       * 2. If a keyword is set, searchMode == "keywords"
       * 3. searchMode == "components"
       */

      /* If there are categories for this board, select the 'Categories' radio box */
      if (this.category) {
        this.searchMode = "categoriesPage";
      } else if (this.keyword) {
        this.searchMode = "keywordsPage";
      } else {
        this.searchMode = "componentsPage";
      }

      if (!this.active) {
        Polymer.dom(this.$.documentation).innerHTML = "Loading...";
      }

      /* Load the board top-level documentation */
      this.$.boardViewer.getDocumentation(null, "HTML", function(results) {
        if (!results || results.error) {
          console.log(results.error);
          return;
        }

        this.boardInfo.html = results.content;

        /* If nothing else is active, set the active to the boardInfo
         * If something is active, and the active item is the boardInfo,
         * then set the "documentation" directly here since the change
         * won't be detected automatically */
        if (!this.active) {
          this.active = this.boardInfo;
        } else if (this.active == this.boardInfo) {
          Polymer.dom(this.$.documentation).innerHTML = results.content;
        }
      }.bind(this));

      /* After everything has loaded and is initialized, *then* set the active
       * selection */
      if (this.selectedOnceLoaded) {
        var category = this.$.boardViewer.findCategory(this.selectedOnceLoaded[0]);
        if (category) {
          this.category = category;
          this.selected = category.list;
        }
        else {
          this.selected = this.selectedOnceLoaded;
        }
        delete this.selectedOnceLoaded;
      }
    },

    updateRoute: function(board, selected, category) {
      /* Start with an empty route by trimming the hash parameters */
      var href = window.location.href.replace(/#.*/, ""),
        params = [];
      /* If the board is set, add it to the URL */
      if (board) {
         href += "#" + board;

        /* If the filters are set, add them to the URL */
        if (board && selected && selected.length) {
          for (var i = 0; i < selected.length; i++) {

            if (this.$.boardViewer.findComponent(selected[i])) {
              params.push(selected[i]);
              continue;
            }

            var keyword = null;
            for (var j = 0; !keyword && j < this.keywords.length; j++) {
              if (this.keywords[j].refdes == selected[i]) {
                keyword = selected[i];
              }
            }
            if (keyword) {
              params.push(keyword);
              continue;
            }

            console.log("Dropping invalid selection: " + selected[i]);
          }
        }

        /* If there is a category set, add it to the first part of the URL */
        if (category) {
          params.unshift(category.slug);
        }

        if (params.length) {
          href += "/" + params.join(",");
        }
      }

      /* If the URL is changing, push it to the window history *IFF* there are
       * not pending selections (if there are, a board is actively loading) */
      if (href != window.location.href && !this.selectedOnceLoaded) {
        /* Add an entry to the window.history to update the URL with the list
         * of active filters */
        window.history.pushState({
          board: board,
          category: category ? category.slug : null,
          selected: selected ? selected.slice() : [] /* Copy of selected array */
        }, board, href);
      }
    },

    buttonTap: function(event) {
      event.preventDefault();

      this.$.boardViewer.setHover({
        type: event.model.item.type,
        refdes: event.model.item.refdes,
        in: true
      });

      var refdes = event.model.item.refdes,
        category = this.$.boardViewer.findCategory(refdes),
        index = this.selected.indexOf(refdes);

      /* If we get a category */
      if (category) {
        /* If category get is not the same as the category alreadey set,
         * then is a new active category */
        if (this.category != category) {
          this.category = category;
          this.selected = category.list;

          if (this.isMobileLayout) {
            this.$.drawer.toggle();
          }

          return;
        }
        /* Otherwise we need to remove it */
        if (this.category == category) {
          this.category = null;
          this.selected = [];

          if (this.isMobileLayout) {
            this.$.drawer.toggle();
          }

          return;
        }
      }

      if (!category) {
        this.category = null;
        if (index == -1) {
          this.selected = [ event.model.item.refdes ];
        } else {
          this.selected.splice(index, 1);
          this.$.boardViewer.setSelected(this.selected);
          this.updateRoute(this.board, this.selected, null);
        }

        if (this.isMobileLayout) {
          this.$.drawer.toggle();
        }

      }
    },

    buttonOver: function(event) {
      event.preventDefault();
      this.$.boardViewer.setHover({
        type: event.model.item.type,
        refdes: event.model.item.refdes,
        in: true
      });
    },

    buttonOut: function(event) {
      event.preventDefault();
      this.$.boardViewer.setHover({
        type: event.model.item.type,
        refdes: event.model.item.refdes,
        in: false
      });
    },

    onHashChange: function(event) {
      if (window.location.hash && this.hash != window.location.hash) {
        this.hash = window.location.hash;
      }
    },

    onPopState: function(event) {
      if (!event.state || !event.state.board) {
        this.hash = window.location.hash;
        return;
      }

      this.board = event.state.board;
      this.selected = event.state.selected;
      this.$.boardViewer.setSelected(this.selected);
      if (this.board != this.$.boardViewer.board) {
        console.log("Loading board via popstate: " + this.board);
        this.$.boardViewer.loadBoard(this.board);
      }
      this.updateRoute(this.board, this.selected, null);
    },

    setBoardAndSelectedFromHash: function(boards, hash) {
      var uri = hash.split("/"),
        boardToLoad = null,
        hash = uri[0].substr(1); /* Prune the # */

      /* If we have a category we stored while are not categories loaded yet. */
      if (uri[2]) {
        this.slug = uri[1];
        uri[1] = uri[2];
        uri.splice(2,1);
      }

      /* If single-board override is in effect, only load the single board
       * and ignore the hash portion of the URL ... */
      if (this.singleBoard) {
        boardToLoad = this.singleBoard;
      } else {
        for (var i = 0; i < this.boards.length; i++) {
          if (this.boards[i].directory == hash) {
            boardToLoad = this.boards[i].directory;
            break;
          }
        }
      }

      if (!boardToLoad) {
        this.selected = [];
        this.$.boardViewer.setSelected(this.selected);
        this.board = "";
        /* If the boards.json has loaded, and no board is going to be loaded,
         * the app is initialized; show the board selector */
         if (!this.isEmpty(this.boards)) {
           this.initialized = true;
           console.log("Initialized to board-selector");
         }

         return;
      }

      // Get selected from the url if there are some.
      if (uri[1]) {
        var tokens = uri[1].split(",");
        for (var i = 0; i < tokens.length; i++) {
          tokens[i] = tokens[i].toUpperCase();
        }
        this.selected = tokens;
      } else {
        this.selected = [];
      }
      if (boardToLoad != this.$.boardViewer.board) {
        console.log("Loading board via setBoardAndSelectedFromHash: " + boardToLoad);
        this.selectedOnceLoaded = this.selected;
        this.$.boardViewer.loadBoard(boardToLoad);
      } else {
        this.$.boardViewer.setSelected(this.selected);
        this.updateRoute(boardToLoad, this.selected, null);
      }
    },

    attached: function() {

      window.addEventListener("popstate", this.onPopState.bind(this));
      window.addEventListener("hashchange", this.onHashChange.bind(this));

      this.$.boardViewer.getBoards(function(boards) {
        if (!boards || boards instanceof Error) {
          this.initialized = true;
          console.log("Initialized to board-selector with no boards.");
          this.$['board-list'].innerHTML = "<div>No boards available to list.</div>";
          window.location.hash = "";
          boards = [];
        }
        this.boards = boards;
        this.hash = window.location.hash;
      }.bind(this));
    }
  });

});
</script>
</dom-module>
</html>
