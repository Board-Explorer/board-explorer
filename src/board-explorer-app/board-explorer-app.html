<!doctype html>
<html>
<head>
  <link rel="import" href="../../bower_components/polymer/polymer.html">

  <link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
  <link rel="import" href="../../bower_components/iron-icons/iron-icons.html">
  <link rel="import" href="../../bower_components/iron-icon/iron-icon.html">
  <link rel="import" href="../../bower_components/iron-pages/iron-pages.html">
  <link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">

  <link rel="import" href="../../bower_components/paper-button/paper-button.html">
  <link rel="import" href="../../bower_components/paper-dropdown-menu/paper-dropdown-menu.html">
  <link rel="import" href="../../bower_components/paper-input/paper-input.html">
  <link rel="import" href="../../bower_components/paper-item/paper-item.html">
  <link rel="import" href="../../bower_components/paper-listbox/paper-listbox.html">
  <link rel="import" href="../../bower_components/paper-material/paper-material.html">
  <link rel="import" href="../../bower_components/paper-tabs/paper-tabs.html">
  <link rel="import" href="../../bower_components/paper-tabs/paper-tab.html">
  <link rel="import" href="../../bower_components/paper-toolbar/paper-toolbar.html">

  <link rel="import" href="../../bower_components/vaadin-split-layout/vaadin-split-layout.html">

  <link rel="import" href="../../bower_components/board-viewer/board-viewer.html">

  <script src="../../bower_components/highlightjs/highlight.pack.min.js"></script>

  <link rel="stylesheet" href="../../bower_components/highlightjs/styles/atom-one-light.css">

  <!--
  `<board-explorer-app>` Provides a container for the board-viewer.

  The board-explorer loads the board-viewer and displays additional selection
  elements for interacting with the board-viewer. It also provides an area
  to render the documentation for a given item (via board-viewer::getDocumentation)

  @demo demo/index.html Simple demo showing a statically loaded view.
  -->

</head>

<dom-module id="board-explorer-app">
<template>
  <style include="iron-flex iron-flex-alignment iron-positioning">
    :host {
      /* Used in board-viewer tab header */
      --focus-foreground-color: #52595a;
      --focus-background-color: #d6eab0;
      --focus-border-color: #97ca41;
      --blur-foreground-color: #52595a;
      --blur-background-color: #f8f8f1;
      --blur-border-color: #f0efe0;
      --bg-l: #f8f8f1;
    }

    #boardTitle {
      cursor: pointer;
    }

    board-viewer {
      position: relative;
      height: 480px;
    }

    #panel-left paper-button {
      cursor: pointer;
      display: inline-block;
      box-sizing: border-box;
      padding: 0.25em 0.5em;
      margin: 0.25em 0.5em;
      border-radius: 3px;
      border: 1px solid rgba(0, 0, 0, 0.5);
      min-width: 8em;
      text-align: center;
      text-decoration: none;
      background-color: #f0f0f0;
      color: black;
      font-size: 1em;
    }

    #panel-left paper-button[disabled] {
      border-style: dashed;
      color: #888;
    }

    #panel-left paper-button.hover,
    #panel-left paper-button:hover {
      background-color: #404040;
      border-color: #00ffff;
      color: #00ffff;
    }

    #panel-left paper-button.connected {
      border-color: #ff8000;
      color: #ff8000;
      background-color: #888;
    }

    #panel-left paper-button.related {
      border-color: #00ff00;
      color: #00ff00;
      background-color: #888;
    }

    #panel-left paper-button.active {
      background-color: #e0e0e0;
    }

    #panel-left paper-button.item-with-name div:first-child {
      font-size: 0.6em;
      line-height: 0.8em;
    }

    #panel-left paper-button.item-with-name div:last-child {
      font-size: 1em;
      line-height: 1em;
    }

    #panel-left paper-button:not(.item-with-name) div:last-child {
      display: none;
    }

    paper-material {
      margin: 0.5em;
      padding: 1em;
    }

    .info-content {
      margin: 1em;
    }

    paper-toolbar {
      --paper-toolbar-background: #f0f0f0;
      --paper-toolbar-color: #444;
      --paper-toolbar-sm-height: 64px;
      padding: 0;
      margin: 0;
      -webkit-transition: 0.15s all ease;
      transition: 0.15s all ease;
    }

    paper-dropdown-menu {
      width: 100%;
    }

    #info div:not(.item-with-name) #name {
      display: none;
    }

    /* NOTE: For this to not horribly squash image aspect ratios, we have
     * the item width hard coded to fixed pixels. We could use various
     * image-fill css attributes, but then we might letterbox the wrong
     * part of the image... */
    .board-card {
      width: 320px;
      cursor: pointer;
      border: 3px solid rgba(255, 255, 255, 0);
      padding: 1rem;
      margin: 0.25rem;
    }

    .board-card > * {
    }

    .board-card:not(.filler) {
      @apply(--board-selector-item-theme);
    }

    .board-card:hover:not(.filler) {
      background-color: #d0e8f8;
    }

    /* fill up the space of the last row */
    .filler {
      dispaly: inline-block;
      width: 320px;
      height: 1px;
      max-height: 1px;
      pointer-events: none;
      margin: 0.25rem;
    }

    .filler.tiny,
    .board-card.tiny {
      width: 100%;
    }

    .board-card .title {
      margin: 0.5em 0;
      width: 100%; /* Fix IE not wrapping text in the paper-button */
    }

    .board-card .image {
      position: relative;
      width: 100%;
      height: calc(240px - 2rem);
      background-size: contain;
      background-position: 50% 50%;
      background-repeat: no-repeat;
    }

    #board-selector .heading {
      margin: 0 0 0.5em 0;
      font-weight: bold;
    }

    #board-selector paper-button {
      margin: 0.5em;
    }

    #documentation table {
      padding: 0px;
      margin: 0px;
      border-spacing: 0px;
    }

    #documentation th,
    #documentation td {
      border-right: 1px solid black;
      padding: 0 0.5em;
    }

    #documentation th {
      border-bottom: 1px solid black;
    }

    #documentation th:last-child,
    #documentation td:last-child {
      border-right: 1px none black;
    }

    #layout {
      height: 100%;
      max-height: 100%;
    }

    #sidebar-left {
      width: 100%;
      max-width: 100%;
    }

    #panel-left {
      width: 33.3%;
      overflow: auto;
    }

    #panel-right {
      width: 66.7%;
      max-width: 100%;
    }

    #panel-bottom {
      height: 33.3%;
    }

    /* Fix IE not wrapping correctly in flex wrap layouts */
    .wrap {
      width: 100%;
    }

    .context-and-name {
      margin-right: 0.5ex;
    }

    .context-and-name:not(:last-of-type):not(:first-of-type) {
      padding-right: 0.5ex;
      border-right: 1px solid #d0d0d0;
    }

    .context-and-name div:first-child {
      font-size: 0.75em;
      min-height: 0.75em;
    }

    .context-and-name div:last-child {
      font-size: 1em;
    }

  </style>

  <paper-material id="board-selector" hidden$="[[hideSelector(board,initialized)]]" class="layout vertical start">
    <div class="vertical layout wrap">
      <div class="heading">Select a board to explore</div>
      <div id="board-list" class="layout horizontal start-justified wrap">
        <template is="dom-repeat" items="[[boards]]">
          <paper-button raised noink class="board-card layout vertical" tabindex$="[[index]]" on-tap="boardTap">
            <div class="image" style$="background-image: url('boards/[[item.board]]/[[item.image]]');">
            </div>
            <div class="title">[[item.name]]</div>
          </paper-button>
        </template>
      </div>
    </div>
  </paper-material>

  <vaadin-split-layout hidden$="[[isEmpty(board)]]" class="horizontal layout justified" id="layout">
    <div id="panel-left">
      <div class="vertical layout flex" id="sidebar-left">

        <paper-material id="boardTitle" on-tap="unloadBoard" class="vertical layout start">
          [[getBoardBoxTitle(board)]]
        </paper-material>

        <paper-material class="vertical layout">
          <paper-tabs id="searchTabs" selected="{{searchMode}}" attr-for-selected="name">
            <paper-tab name="searchPage">Search</paper-tab>
            <paper-tab name="categoriesPage" hidden$="[[isEmpty(categories)]]">Categories</paper-tab>
            <paper-tab name="keywordsPage">Keywords</paper-tab>
            <paper-tab name="componentsPage">Components</paper-tab>
            <paper-tab name="overviewPage" hidden>Get to know the board</paper-tab>
          </paper-tabs>
        </paper-material>

        <paper-material class="vertical layout">
          <iron-pages id="pages" selected="[[searchMode]]" attr-for-selected="id">
            <div id="searchPage" class="vertical layout">
              <paper-input id="search" value="{{search}}" label="Search" class="flex">
                <iron-icon suffix slot="suffix" icon="search"></iron-icon>
              </paper-input>
              <div hidden$="[[!isEmpty(search)]]">Enter a string to search (for example "I2C").</div>
              <div hidden$="[[isEmpty(search)]]">
                <div>Search results</div>
                <div hidden$="[[!isEmpty(matches)]]">No matches.</div>
                <div class="layout horizontal wrap">
                  <template is="dom-repeat" items="[[matches]]">
                    <paper-button match$="[[item.refdes]]"
                      on-tap="buttonTap"
                      on-mouseover="buttonOver"
                      on-mouseout="buttonOut">
                      <b>[[itemName(item)]]</b> - [[item.field]]: [[item.value]]
                    </paper-button>
                  </template>
                </div>
              </div>
            </div>

            <div id="categoriesPage" class="vertical layout">
              <div>Categories</div>
              <div class="layout horizontal wrap">
                <template is="dom-repeat" items="[[categories]]">
                  <paper-button match$="[[item.slug]]"
                    on-tap="buttonTap"
                    on-mouseover="buttonOver"
                    on-mouseout="buttonOut">
                    [[item.name]]
                  </paper-button>
                </template>
              </div>
            </div>

            <div id="keywordsPage" class="vertical layout">
              <div>Keywords</div>
              <div class="horizontal layout wrap">
                <template is="dom-repeat" items="[[keywords]]">
                  <paper-button match$="[[item.refdes]]"
                    on-tap="buttonTap"
                    on-mouseover="buttonOver"
                    on-mouseout="buttonOut">
                    [[item.refdes]]
                  </paper-button>
                </template>
              </div>
            </div>

            <div id="componentsPage" class="vertical layout start">
              <div>Components</div>
              <div class="layout horizontal wrap">
                <template is="dom-repeat" items="[[components]]">
                  <paper-button match$="[[item.refdes]]"
                    class$="[[itemClassList(item)]] layout vertical start"
                    on-tap="buttonTap"
                    on-mouseover="buttonOver"
                    on-mouseout="buttonOut">
                    <div>[[itemRefDes(item)]]</div>
                    <div>[[itemName(item)]]</div>
                  </paper-button>
                </template>
              </div>
            </div>
          </iron-pages>
        </paper-material>

      </div>
    </div>

    <vaadin-split-layout vertical id="panel-right">
      <board-viewer
        class="flex-grow"
        hidden$="[[isEmpty(board)]]"
        id="boardViewer"
        selected="{{selected}}"
        disable-auto-resize
        enable-zoom
        enable-drag></board-viewer>
      <div id="panel-bottom">
        <div id="info"
          hidden$="[[isEmpty(hover)]]"
          class$="[[itemClassList(hover)]] vertical layout">
          <paper-toolbar>
            <div hidden$="[[hideReadable(hover)]]"
              class="context-and-name layout vertical justified start">
              <div>&nbsp;</div>
              <div>[[hover.readable]]: </div>
            </div>
            <template is="dom-repeat" items="[[_getItemNamesAndContexts(hover)]]">
              <div class="context-and-name layout vertical justified start">
                <div>[[item.context]]</div>
                <div>[[item.name]]</div>
              </div>
            </template>
          </paper-toolbar>
          <div class="info-content">
            <div hidden$="[[isEmpty(hover.component)]]">Component: [[hover.component]]</div>
            <div hidden$="[[isEmpty(hover.pins)]]">Pins: [[hover.pins.length]]</div>
            <div hidden$="[[isEmpty(hover.keywords)]]">Keywords:
              <template is="dom-repeat" items="[[hover.keywords]]" as="keyword">
                <a href="#[[board]]/[[keyword]]">[[keyword]]</a>
              </template>
            </div>
            <div hidden$="[[isEmpty(hover.description)]]">Description: [[hover.description]]</div>
            <div><div id="documentation"></div></div>
          </div>
        </div>
      </div>
    </vaadin-split-layout>

  </vaadin-split-layout>

</template>
<script>
"use strict";

document.addEventListener("WebComponentsReady", function() {
  Polymer({
    is: "board-explorer-app",
    properties: {
      boards: {
        type: Array,
        value: []
      },
      board: {
        type: String,
        value: null
      },
      categories: {
        type: Array,
        value: []
      },
      category: {
        type: Object,
        value: null
      },
      slug: {
        type: String,
        value: null
      },
      keywords: {
        type: Array,
        value: []
      },

      selected: {
        type: Array,
        value: []
      },

      components: {
        type: Array,
        value: []
      },

      pins: {
        type: Array,
        value: []
      },
      pin: {
        type: Object,
        value: null
      },

      infoTitle: {
        type: String,
        value: ""
      },

      hover: { /* item currently hovered over */
        type: Object,
        value: null
      },
      fetching: {
        type: Boolean,
        value: false
      },
      initialized: {
        type: Boolean,
        value: false
      }

    },

    observers: [
      "onComponentChanged(component)",
      "onHoverChanged(hover)",
      "setBoardAndSelectedFromHash(boards, hash)",
      "_searchModeChanged(searchMode)",
      "_searchChanged(search)"
    ],

    listeners: {
      "boardViewer.board-changed": "onBoardChanged",
      "boardViewer.item-hover": "onBoardItemHover",
      "boardViewer.selected-changed": "onBoardSelectedChanged",
      "search.focused-changed": "_searchFocus"
    },

    _searchChanged: function(search) {
      if (this.isEmpty(search)) {
        this.matches = [];
        return;
      }

      var matches = [],
        regexp = new RegExp(search.replace(/[-^$\\*\/+?().|[\]{}]/g, '\\$&'), "i");

      function _matchItem(regexp, item) {
        var fields = [ "name", "refdes", "description" ];
        for (var i = 0; i < fields.length; i++) {
          var result = regexp.exec(item[fields[i]]);
          if (!result) {
            continue;
          }
          return {
            type: item.type,
            item: item,
            name: item.name || item.readable || "",
            refdes: item.refdes,
            field: fields[i],
            value: item[fields[i]],
            match: result
          };
        }

        if (item.keywords) {
          for (var i = 0; i < item.keywords.length; i++) {
            var result = regexp.exec(item.keywords[i]);
            if (!result) {
              return;
            }
            return {
              type: item.type,
              item: item,
              refdes: item.refdes,
              name: item.name || item.readable || "",
              field: "keyword",
              value: item.keywords[i],
              match: result
            };
          }
        }
        return null;
      }

      this.components.forEach(function(item) {
        var match = _matchItem(regexp, item);
        if (match) {
          matches.push(match);
        }

        if (item.pins) {
          item.pins.forEach(function(pin) {
            var match = _matchItem(regexp, pin);
            if (match) {
              matches.push(match);
            }
          });
        }
      });

      this.keywords.forEach(function(item) {
        var result = regexp.exec(item.keyword);
        if (!result) {
          return;
        }
        matches.push({
          type: "keyword",
          field: "keyword",
          refdes: item.keyword,
          keyword: item.keyword,
          value: item.keyword,
          match: result
        });
      });

      this.categories.forEach(function(item) {
        var result = regexp.exec(item.name);
        if (!result) {
          return;
        }
        matches.push({
          type: "category",
          field: "category",
          refdes: item.slug,
          value: item.name,
          slug: item.slug,
          match: result
        });
      });

      this.matches = matches;
    },

    _searchFocus: function(event) {
      if (event.detail.value) {
        this.searchMode = "searchPage";
      }
    },

    _enableItemButtons: function(item) {
      var el;

      if (!item) {
        return;
      }

      el = this.querySelector("paper-button[match='" + item.refdes + "']");
      if (el) {
        el.disabled = false;
      }

      for (var i = 0; i < item.connected.length; i++) {
        el = this.querySelector("paper-button[match='" + item.connected[i] + "']");
        if (el) {
          el.disabled = false;
        }
      }
      for (var i = 0; i < item.related.length; i++) {
        el = this.querySelector("paper-button[match='" + item.related[i] + "']");
        if (el) {
          el.disabled = false;
        }
      }
    },

    _setAssociatedItemButtonsStyle: function(item) {
      var el;

      if (!item) {
        return;
      }

      /* Walk through the connected and related items for this item.
       * If a relation is to a pin, then activate it's containing
       * component's button */
      var item, list = [];
      for (var i = 0; i < item.connected.length; i++) {
        item = this.$.boardViewer.findComponent(item.connected[i]);
        if (!item) {
          continue;
        }
        list.push({
          refdes: item.component ? item.component : item.refdes,
          style: "connected"
        });
      }
      for (var i = 0; i < item.related.length; i++) {
        item = this.$.boardViewer.findComponent(item.related[i]);
        if (!item) {
          continue;
        }
        list.push({
          refdes: item.component ? item.component : item.refdes,
          style: "related"
        });
      }

      list.forEach(function(item) {
        el = this.$[this.searchMode].querySelector("paper-button[match='" + item.refdes + "']");
        if (el) {
          el.classList.add(item.style);
        }
      }.bind(this));
    },


    onBoardSelectedChanged: function(event) {
      if (!this.board) {
        return;
      }

      var selected = this.$.boardViewer.selected || [];

      /* If no selection is active, then enable everything and return */
      if (selected.length == 0) {
        Array.prototype.forEach.call(this.$.keywordsPage.querySelectorAll("paper-button"), function(el) {
          el.disabled = false;
        });
        Array.prototype.forEach.call(this.$.componentsPage.querySelectorAll("paper-button"), function(el) {
          el.disabled = false;
        });
        return;
      }

      /* Disable all items in the currently viewed page */
      Array.prototype.forEach.call(this.$.keywordsPage.querySelectorAll("paper-button"), function(el) {
        el.disabled = true;
      });
      Array.prototype.forEach.call(this.$.componentsPage.querySelectorAll("paper-button"), function(el) {
        el.disabled = true;
      });

      /* Walk through the list of selected items and enable them in the
       * keywords and components */
      selected.forEach(function(refdes) {
        /* Disable the button that matches this refdes */
        var el = this.querySelector("paper-button[match='"+refdes+"']");
        if (el) {
          el.disabled = false;
        }

        /* Check if it is a component/pin... */
        var item = this.$.boardViewer.findComponent(refdes);
        if (!item) {
          /* It's a keyword, so return */
          return;
        }

        this._enableItemButtons(item);

        /* If the item is part of a component, enable the component too */
        if (item.component) {
          this._enableItemButtons(this.$.boardViewer.findComponent(item.component));
        }
      }.bind(this));

      console.log("TODO: Figure out how to get this.selected to be two-way with board-viewer");
      this.updateRoute(this.board, this.$.boardViewer.selected || []);
    },

    _getItemNamesAndContexts: function(item) {
      /* If no item is set, there is no name */
      if (!item) {
        return [];
      }

      /* If this item has defined its own context, return it */
      if ("context" in item && typeof item.context === "string") {
        return [ { context: item.context, name: item.name } ];
      }

      /* If the item is not within a component, then
       * there are no contexts; return just "default" */
      if (!item.component) {
        return [ { context: "Generic name", name: item.name } ];
      }

      var NaCs = [],
        component = this.$.boardViewer.getInfo(item.component);

      /* If there are no contexts, return just "default" */
      if (!component || !component.contexts) {
        return [ { context: "Generic name", name: item.name } ];
      }

      for (var i = 0; i < component.contexts.length; i++) {
        /* `name` can either be a single entry, or an array of names for
         * each context. If a context does not have a specific name, N/A is
         * provided */
        NaCs.push({
          context: component.contexts[i],
          name: Array.isArray(item.name) ?
            ((typeof item.name[i] === "string") ? item.name[i] : "N/A") : /* If a context slot is missing, N/A */
            (i == 0 ? item.name : "N/A") /* A single name is only provided for the first context */
        });
      }
      return NaCs;
    },

    _searchModeChanged: function(searchMode) {
      console.log("Mode changed to " + searchMode);

      this.$.boardViewer.selected = [];
      this.$.boardViewer.setHover();

      if (searchMode == "searchPage") {
        this.$.search.value = "";
        this.$.search.focus();
      } else {
        console.log("Setting focus to " + searchMode);
        this.$.searchTabs.querySelector("[name='" + searchMode + "']").focus();
      }

      var searchTabs = Polymer.dom(this.root).querySelectorAll('[control]');
      for (var i = 0; i < searchTabs.length; i++) {
        var attr = searchTabs[i].getAttribute('control');
        searchTabs[i].hidden = (attr == event.detail.value) ? false : true;
      }
    },

    hideSelector: function(board, initialized) {
      return !this.isEmpty(board) || !initialized;
    },

    hideReadable: function(item) {
      return !item || this.isEmpty(item.readable) ||  item.readable == item.name;
    },

    unloadBoard: function() {
      this.$.boardViewer.loadBoard();
      /* Remove all selected */
      this.selected = [];
      this.$.boardViewer.setSelected(this.selected);
      this.infoTitle = "";
      this.category = null;
      this.updateRoute(this.board, this.selected);
    },

    itemClassList: function(item) {
      var name = item ? item.name : null;
      if (name && name != item.readable) {
        return "item-with-name";
      }
      return "";
    },

    itemRefDes: function(item) {
      return item.readable || item.refdes || "";
    },

    itemDescription: function(item) {
      return item.description || "";
    },

    itemName: function(item) {
      return item.name || item.readable || item.refdes || "";
    },

    isEmpty: function(/*item0, ... */) {
      /* If all parameters passed are empty, return true */
      for (var i = 0; i < arguments.length; i++) {
        var item = arguments[i];
        if (item
          && (!Array.isArray(item) || item.length != 0)
          && item != null
          && item != "") {
          return false;
        }
      }

      return true;
    },

    getBoardBoxTitle: function(name) {
      if (!name) {
        return;
      }

      for (var i = 0; i < this.boards.length; i++) {
        if (this.boards[i].directory == name) {
          return this.boards[i].name;
        }
      }
    },

    getDocumentation: function(item, type) {
      return new Promise(function(resolve, reject) {
        if (item.html) {
          return resolve({
            status: 200,
            content: item.html
          });
        }

        this.$.boardViewer.getDocumentation(item.refdes, type, function(results) {
          if (!results || results.error) {
            if (results.status == 400) {
              return resolve({status: 400});
            }
            return reject(new Error(results.error));
          }

          return resolve(results);
        });
      }.bind(this));
    },

    loadingQueue: function(item) {
      /* If there is already a load in progress, set the next load
       * to this item */
      if (this.loading) {
        this.loading = item;
        return;
      }

      /* Load this item */
      this.loading = item;

      this.getDocumentation(item, "HTML").then(function(item, results) {
        if (results.status == 200) {
          return results.content;
        }

        if (results.status != 400) {
          return Promise.reject(new Error("Error returned from getDocumentation"));
        }

        /* If there was no content, and there is a parent component,
         * and the current hover item is still the one being fetched,
         * fetch the documentation for the parent component and set this
         * item's content to that */
        if (!item.component) {
          return "<p>No additional documentation for " + item.refdes;
        }

        var component = this.$.boardViewer.findComponent(item.component);
        if (component.html) {
          return component.html;
        }

        /* If the current hover item is no longer this one, do not chain
         * to lookup the component's documentation. */
        if (this.hover != item) {
          return Promise.reject();
        }

        return this.getDocumentation(component, "HTML").then(function(results) {
          if (results.status == 200) {
            component.html = "<p>No additional documentation for " + component.refdes;
            return component.html;
          }
          return results.content;
        });
      }.bind(this, item)).then(function(item, html) {
        item.html = html;

        /* If this is the item currently being hovered on, notify the UI
         * to update the DOM */
        if (this.hover == item) {
          Polymer.dom(this.$.documentation).innerHTML = html;
        }
      }.bind(this, item)).catch(function(item, error) {
        return "<p>No additional documentation for " + item.refdes;
      }.bind(this, item)).then(function(item) {
        /* Fire off the most recent load request if it changed while the above
         * was resolving */
        if (this.loading != item) {
          item = this.loading;
          this.loading = null;
          if (item) {
            this.loadingQueue(item);
          }
        } else {
          this.loading = null;
        }
      }.bind(this, item));
    },

    onHoverChanged: function(hover) {
      if (!hover) {
        return;
      }

      if (hover.html) {
        Polymer.dom(this.$.documentation).innerHTML = hover.html;
        return;
      }

      Polymer.dom(this.$.documentation).innerHTML = "Loading...";
      this.loadingQueue(hover);
    },

    onBoardItemHover: function(event) {
      var info = event.detail,
        item = this.$.boardViewer.findComponent(info.refdes),
        el;

      if (!item) {
        return;
      }

      /* Clear all "related", "connected", and "hover" highlights */
      [ "related", "connected", "hover" ].forEach(function(style) {
        Array.prototype.forEach.call(this.querySelectorAll("paper-button." + style),
            function(el) {
          el.classList.remove(style);
        });
      }.bind(this));

      /* If the direction is IN, add "related" to all KEYWORDs for this item */
      if (info.in) {
        item.keywords.forEach(function(keyword) {
          el = this.$.keywordsPage.querySelector("paper-button[match='" + keyword + "']");
          if (el) {
            el.classList.add("hover");
          }
        }.bind(this));
      }

      /* If a pin is being hovered over in the board-viewer, then set the
       * pin's containing component as the active button hover */
      if (item.component && info.source == "board-viewer") {
        info.refdes = item.component;
      }

      /* Toggle the "hover" state for the item */
      el = this.$[this.searchMode].querySelector("paper-button[match='" + info.refdes + "']");
      if (el) {
        el.classList.toggle("hover", info.in);
        if (info.in && info.source == "board-viewer") {
          el.scrollIntoView();
        }
      }

      if (info.in) {
        this._setAssociatedItemButtonsStyle(item);
      }

      /* Leaving an item */
      if (!info.in) {
        if (this.hover == item) {
          /* If no item has been selected via tapping, hover will show info */
          if (!this.active) {
            this.hover = null; /* Force DOM update */
            this.hover = this.boardInfo;
          }
        }

        /* If the hover is leaving the item, and the last hover has not yet
         * triggered, clear the debounce. */
        if (this.pendingHover == item) {
          this.pendingHover = null;
          this.cancelDebouncer("pendingHover");
        } else {
          /* Otherwise clear the item leaving */
        }

        return;
      }

      /* Entering an item */
      this.pendingHover = item;
      /* If no item has been selected via tapping, hover will show info */
      if (!this.active) {
        this.hover = null; /* Force DOM update */
        this.hover = item;
      }


      this.debounce("pendingHover", function() {
        if (!this.pendingHover) {
          return;
        }
        this.pendingHover = null;
      }, 100);
    },

    boardTap: function(event) {
      var board = event.model.item.directory;
      console.log("Loading " + board);
      /* Remove all selected */
      this.selected = [];
      this.$.boardViewer.setSelected(this.selected);
      if (this.$.boardViewer.board != board) {
        console.log("Loading board via boardTap");
        this.$.boardViewer.loadBoard(board);
      }
      this.updateRoute(board, this.selected);
    },

    onBoardChanged: function(event) {
      var board = event.detail.value || "";

      this.active = null;
      this.hover = null;

      this.board = board;
      this.keywords = [];
      this.pins = [];
      this.components = [];
      this.categories = [];

      if (!board) {
        console.log("Board Explorer unloaded board.");
        return;
      }

      this.boardLoaded();
    },

    boardLoaded: function() {
      console.log("Board Explorer has a board loaded and ready.");
      /* If a board has been set, the app is initialized */
      this.initialized = true;

      this.boardInfo = {
        context: "",
        name: this.board,
        html: "No description of " + this.board + " available."
      };

      for (var i = 0; i < this.boards.length; i++) {
        if (this.boards[i].directory === this.board) {
          this.boardInfo.name = this.boards[i].name;
          break;
        }
      }

      console.log("Asking for keywords...");
      var keywords = [];
      this.$.boardViewer.getKeywords().forEach(function(keyword) {
        keywords.push({
          type: "keyword",
          refdes: keyword
        });
      });
      this.keywords = keywords;

      console.log("Asking for components...");
      var components = [];
      this.$.boardViewer.getComponents().forEach(function(refdes) {
        components.push(this.$.boardViewer.getInfo(refdes));
      }.bind(this));

      this.components = components;

      this.categories = this.$.boardViewer.getCategories();

      /* When the application loads, the default filter is set as follows:
       * 1. If a category is set, searchMode == "categories"
       * 2. If a keyword is set, searchMode == "keywords"
       * 3. searchMode == "components"
       */

      /* If there are categories for this board, select the 'Categories' radio box */
      if (this.category) {
        this.searchMode = "categoriesPage";
      } else if (this.keyword) {
        this.searchMode = "keywordsPage";
      } else {
        this.searchMode = "componentsPage";
      }

      /* Load the board top-level documentation */
      this.$.boardViewer.getDocumentation(null, "HTML", function(results) {
        if (!results || results.error) {
          console.log(results.error);
          this.hover = null; /* Force DOM update */
          this.hover = this.boardInfo;
          return;
        }

        this.boardInfo.html = results.content;
        if (!this.active) {
          this.hover = null; /* Force DOM update */
          this.hover = this.boardInfo;
        }
      }.bind(this));
    },

    updateRoute: function(board, selected) {
      /* Start with an empty route by trimming the hash parameters */
      var href = window.location.href.replace(/#.*/, ""),
        params = [];

      /* If the board is set, add it to the URL */
      if (board) {
         href += "#" + board;

        /* If the filters are set, add them to the URL */
        if (board && selected && selected.length) {
          for (var i = 0; i < selected.length; i++) {
            if (this.$.boardViewer.findComponent(selected[i])) {
              params.push(selected[i]);
              break;
            }

            if (this.keywords.indexOf(selected[i]) != -1) {
              params.push(selected[i]);
              break;
            }

            console.log("Dropping invalid selection: " + selected[i]);
          }
        }

        /* If there is a category set, add it to the first part of the URL */
        if (this.category) {
          params.unshift(this.category.slug);
        }

        if (params.length) {
          href += "/" + params.join(",");
        }
      }

      /* If the URL is changing, push it to the window history */
      if (href != window.location.href) {
        /* Add an entry to the window.history to update the URL with the list
         * of active filters */
        window.history.pushState({
          board: board,
          category: this.category ? this.category.slug : null,
          selected: selected ? selected.slice() : [] /* Copy of selected array */
        }, board, href);
      }
    },

    buttonTap: function(event) {
      event.preventDefault();

      var refdes = event.model.item.refdes,
        index = this.selected.indexOf(refdes);

      if (index == -1) {
        this.selected = [ event.model.item.refdes ];
      } else {
        this.selected.splice(index, 1);
        this.$.boardViewer.setSelected(this.selected);
        this.updateRoute(this.board, this.selected);
      }
    },

    buttonOver: function(event) {
      event.preventDefault();

      this.$.boardViewer.setHover({
        type: event.model.item.type,
        refdes: event.model.item.refdes,
        in: true
      });
    },

    buttonOut: function(event) {
      event.preventDefault();

      this.$.boardViewer.setHover({
        type: event.model.item.type,
        refdes: event.model.item.refdes,
        in: false
      });
    },

    onHashChange: function(event) {
      if (window.location.hash) {
        this.hash = window.location.hash;
      }
    },

    onPopState: function(event) {
      if (!event.state || !event.state.board) {
        this.hash = window.location.hash;
        return;
      }

      this.board = event.state.board;
      this.selected = event.state.selected;
      this.$.boardViewer.setSelected(this.selected);
      if (this.board != this.$.boardViewer.board) {
        console.log("Loading board via popstate: " + this.board);
        this.$.boardViewer.loadBoard(this.board);
      }
      this.updateRoute(this.board, this.selected);
    },

    setBoardAndSelectedFromHash: function(boards, hash) {
      var uri = hash.split("/"),
        boardToLoad = null,
        hash = uri[0].substr(1); /* Prune the # */

        /* If we have a category we stored while are not categories loaded yet. */
        if (uri[2]) {
          this.slug = uri[1];
          uri[1] = uri[2];
          uri.splice(2,1);
        }

      for (var i = 0; i < this.boards.length; i++) {
        if (this.boards[i].directory == hash) {
          boardToLoad = this.boards[i].directory;
          break;
        }
      }

      if (!boardToLoad) {
        this.selected = [];
        this.$.boardViewer.setSelected(this.selected);
        this.board = "";
        /* If the boards.json has loaded, and no board is going to be loaded,
         * the app is initialized; show the board selector */
         if (!this.isEmpty(this.boards)) {
           this.initialized = true;
           console.log("Initialized to board-selector");
         }
      } else {
        // Get selected from the url if there are some.
        if (uri[1]) {
          this.selected = uri[1].split(",");
        } else {
          this.selected = [];
        }
        this.$.boardViewer.setSelected(this.selected);
        if (boardToLoad != this.$.boardViewer.board) {
          console.log("Loading board via setBoardAndSelectedFromHash: " + boardToLoad);
          this.$.boardViewer.loadBoard(boardToLoad);
        }
      }

      this.updateRoute(boardToLoad, this.selected);
    },

    attached: function() {
      window.addEventListener("popstate", this.onPopState.bind(this));
      window.addEventListener("hashchange", this.onHashChange.bind(this));

      (function() {
        var oldHash = null;
        function check() {
          if (oldHash != window.location.hash) {
            oldHash = window.location.hash;
            this.onHashChange(oldHash);
          }
          setTimeout(check.bind(this), 100);
        }

        check.call(this);
      }.bind(this))();

      this.$.boardViewer.getBoards(function(boards) {
        if (!boards || boards instanceof Error) {
          this.initialized = true;
          console.log("Initialized to board-selector with no boards.");
          this.$['board-list'].innerHTML = "<div>No boards available to list.</div>";
          window.location.hash = "";
          boards = [];
        }
        this.boards = boards;
        this.hash = window.location.hash;
      }.bind(this));
    }
  });
});
</script>
</dom-module>
</html>
